{
  "version": 3,
  "sources": ["../../../node_modules/@remix-run/events/src/lib/interactions.ts", "../../../node_modules/@remix-run/events/src/lib/events.ts", "../../../node_modules/@remix-run/events/src/lib/targets.ts", "../../../node_modules/@remix-run/events/src/lib/invariant.ts", "../../../node_modules/@remix-run/events/src/interactions/press.ts", "../../../node_modules/@remix-run/headers/src/lib/param-values.ts", "../../../node_modules/@remix-run/headers/src/lib/utils.ts", "../../../node_modules/@remix-run/headers/src/lib/accept.ts", "../../../node_modules/@remix-run/headers/src/lib/accept-encoding.ts", "../../../node_modules/@remix-run/headers/src/lib/accept-language.ts", "../../../node_modules/@remix-run/headers/src/lib/cache-control.ts", "../../../node_modules/@remix-run/headers/src/lib/content-disposition.ts", "../../../node_modules/@remix-run/headers/src/lib/content-type.ts", "../../../node_modules/@remix-run/headers/src/lib/cookie.ts", "../../../node_modules/@remix-run/headers/src/lib/if-none-match.ts", "../../../node_modules/@remix-run/headers/src/lib/set-cookie.ts", "../../../node_modules/@remix-run/headers/src/lib/header-names.ts", "../../../node_modules/@remix-run/headers/src/lib/super-headers.ts", "../../../node_modules/@remix-run/multipart-parser/src/lib/read-stream.ts", "../../../node_modules/@remix-run/multipart-parser/src/lib/buffer-search.ts", "../../../node_modules/@remix-run/multipart-parser/src/lib/multipart.ts", "../../../node_modules/@remix-run/multipart-parser/src/lib/multipart-request.ts", "../../../node_modules/@remix-run/form-data-parser/src/lib/form-data.ts", "../../../node_modules/@remix-run/fetch-router/src/lib/app-storage.ts", "../../../node_modules/@remix-run/route-pattern/src/lib/split.ts", "../../../node_modules/@remix-run/route-pattern/src/lib/search-constraints.ts", "../../../node_modules/@remix-run/route-pattern/src/lib/parse.ts", "../../../node_modules/@remix-run/route-pattern/src/lib/href.ts", "../../../node_modules/@remix-run/route-pattern/src/lib/stringify.ts", "../../../node_modules/@remix-run/route-pattern/src/lib/join.ts", "../../../node_modules/@remix-run/route-pattern/src/lib/route-pattern.ts", "../../../node_modules/@remix-run/route-pattern/src/lib/regexp-matcher.ts", "../../../node_modules/@remix-run/fetch-router/src/lib/route-map.ts", "../../../node_modules/@remix-run/fetch-router/src/lib/form-action.ts", "../../../node_modules/@remix-run/fetch-router/src/lib/response-helpers.ts", "../../../node_modules/@remix-run/fetch-router/src/lib/request-methods.ts", "../../../node_modules/@remix-run/fetch-router/src/lib/resource.ts", "../../../node_modules/@remix-run/fetch-router/src/lib/middleware.ts", "../../../node_modules/@remix-run/fetch-router/src/lib/request-context.ts", "../../../node_modules/@remix-run/fetch-router/src/lib/route-handlers.ts", "../../../node_modules/@remix-run/fetch-router/src/lib/router.ts", "../../routes.ts", "../../../node_modules/@remix-run/dom/src/jsx-runtime.ts", "../../app/components/assets/Counter.tsx"],
  "sourcesContent": [null, null, null, null, null, "export function parseParams(\n  input: string,\n  delimiter: ';' | ',' = ';',\n): [string, string | undefined][] {\n  // This parser splits on the delimiter and unquotes any quoted values\n  // like `filename=\"the\\\\ filename.txt\"`.\n  let parser =\n    delimiter === ';'\n      ? /(?:^|;)\\s*([^=;\\s]+)(\\s*=\\s*(?:\"((?:[^\"\\\\]|\\\\.)*)\"|((?:[^;]|\\\\\\;)+))?)?/g\n      : /(?:^|,)\\s*([^=,\\s]+)(\\s*=\\s*(?:\"((?:[^\"\\\\]|\\\\.)*)\"|((?:[^,]|\\\\\\,)+))?)?/g\n\n  let params: [string, string | undefined][] = []\n\n  let match\n  while ((match = parser.exec(input)) !== null) {\n    let key = match[1].trim()\n\n    let value: string | undefined\n    if (match[2]) {\n      value = (match[3] || match[4] || '').replace(/\\\\(.)/g, '$1').trim()\n    }\n\n    params.push([key, value])\n  }\n\n  return params\n}\n\nexport function quote(value: string): string {\n  if (value.includes('\"') || value.includes(';') || value.includes(' ')) {\n    return `\"${value.replace(/\"/g, '\\\\\"')}\"`\n  }\n  return value\n}\n", "export function capitalize(str: string): string {\n  return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase()\n}\n\nexport function isIterable<T>(value: any): value is Iterable<T> {\n  return value != null && typeof value[Symbol.iterator] === 'function'\n}\n\nexport function isValidDate(date: unknown): boolean {\n  return date instanceof Date && !isNaN(date.getTime())\n}\n\nexport function quoteEtag(tag: string): string {\n  return tag === '*' ? tag : /^(W\\/)?\".*\"$/.test(tag) ? tag : `\"${tag}\"`\n}\n", "import { type HeaderValue } from './header-value.ts'\nimport { parseParams } from './param-values.ts'\nimport { isIterable } from './utils.ts'\n\nexport type AcceptInit = Iterable<string | [string, number]> | Record<string, number>\n\n/**\n * The value of a `Accept` HTTP header.\n *\n * [MDN `Accept` Reference](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept)\n *\n * [HTTP/1.1 Specification](https://datatracker.ietf.org/doc/html/rfc7231#section-5.3.2)\n */\nexport class Accept implements HeaderValue, Iterable<[string, number]> {\n  #map: Map<string, number>\n\n  constructor(init?: string | AcceptInit) {\n    this.#map = new Map()\n\n    if (init) {\n      if (typeof init === 'string') {\n        for (let piece of init.split(/\\s*,\\s*/)) {\n          let params = parseParams(piece)\n          if (params.length < 1) continue\n\n          let mediaType = params[0][0]\n          let weight = 1\n\n          for (let i = 1; i < params.length; i++) {\n            let [key, value] = params[i]\n            if (key === 'q') {\n              weight = Number(value)\n              break\n            }\n          }\n\n          this.#map.set(mediaType.toLowerCase(), weight)\n        }\n      } else if (isIterable(init)) {\n        for (let mediaType of init) {\n          if (Array.isArray(mediaType)) {\n            this.#map.set(mediaType[0].toLowerCase(), mediaType[1])\n          } else {\n            this.#map.set(mediaType.toLowerCase(), 1)\n          }\n        }\n      } else {\n        for (let mediaType of Object.getOwnPropertyNames(init)) {\n          this.#map.set(mediaType.toLowerCase(), init[mediaType])\n        }\n      }\n\n      this.#sort()\n    }\n  }\n\n  #sort() {\n    this.#map = new Map([...this.#map].sort((a, b) => b[1] - a[1]))\n  }\n\n  /**\n   * An array of all media types in the header.\n   */\n  get mediaTypes(): string[] {\n    return Array.from(this.#map.keys())\n  }\n\n  /**\n   * An array of all weights (q values) in the header.\n   */\n  get weights(): number[] {\n    return Array.from(this.#map.values())\n  }\n\n  /**\n   * The number of media types in the `Accept` header.\n   */\n  get size(): number {\n    return this.#map.size\n  }\n\n  /**\n   * Returns `true` if the header matches the given media type (i.e. it is \"acceptable\").\n   * @param mediaType The media type to check.\n   * @returns `true` if the media type is acceptable, `false` otherwise.\n   */\n  accepts(mediaType: string): boolean {\n    return this.getWeight(mediaType) > 0\n  }\n\n  /**\n   * Gets the weight of a given media type. Also supports wildcards, so e.g. `text/*` will match `text/html`.\n   * @param mediaType The media type to get the weight of.\n   * @returns The weight of the media type.\n   */\n  getWeight(mediaType: string): number {\n    let [type, subtype] = mediaType.toLowerCase().split('/')\n\n    for (let [key, value] of this) {\n      let [t, s] = key.split('/')\n      if (\n        (t === type || t === '*' || type === '*') &&\n        (s === subtype || s === '*' || subtype === '*')\n      ) {\n        return value\n      }\n    }\n\n    return 0\n  }\n\n  /**\n   * Returns the most preferred media type from the given list of media types.\n   * @param mediaTypes The list of media types to choose from.\n   * @returns The most preferred media type or `null` if none match.\n   */\n  getPreferred(mediaTypes: string[]): string | null {\n    let sorted = mediaTypes\n      .map((mediaType) => [mediaType, this.getWeight(mediaType)] as const)\n      .sort((a, b) => b[1] - a[1])\n\n    let first = sorted[0]\n\n    return first !== undefined && first[1] > 0 ? first[0] : null\n  }\n\n  /**\n   * Returns the weight of a media type. If it is not in the header verbatim, this returns `null`.\n   * @param mediaType The media type to get the weight of.\n   * @returns The weight of the media type, or `null` if it is not in the header.\n   */\n  get(mediaType: string): number | null {\n    return this.#map.get(mediaType.toLowerCase()) ?? null\n  }\n\n  /**\n   * Sets a media type with the given weight.\n   * @param mediaType The media type to set.\n   * @param weight The weight of the media type. Defaults to 1.\n   */\n  set(mediaType: string, weight = 1): void {\n    this.#map.set(mediaType.toLowerCase(), weight)\n    this.#sort()\n  }\n\n  /**\n   * Removes the given media type from the header.\n   * @param mediaType The media type to remove.\n   */\n  delete(mediaType: string): void {\n    this.#map.delete(mediaType.toLowerCase())\n  }\n\n  /**\n   * Checks if a media type is in the header.\n   * @param mediaType The media type to check.\n   * @returns `true` if the media type is in the header (verbatim), `false` otherwise.\n   */\n  has(mediaType: string): boolean {\n    return this.#map.has(mediaType.toLowerCase())\n  }\n\n  /**\n   * Removes all media types from the header.\n   */\n  clear(): void {\n    this.#map.clear()\n  }\n\n  entries(): IterableIterator<[string, number]> {\n    return this.#map.entries()\n  }\n\n  [Symbol.iterator](): IterableIterator<[string, number]> {\n    return this.entries()\n  }\n\n  forEach(\n    callback: (mediaType: string, weight: number, header: Accept) => void,\n    thisArg?: any,\n  ): void {\n    for (let [mediaType, weight] of this) {\n      callback.call(thisArg, mediaType, weight, this)\n    }\n  }\n\n  toString(): string {\n    let pairs: string[] = []\n\n    for (let [mediaType, weight] of this.#map) {\n      pairs.push(`${mediaType}${weight === 1 ? '' : `;q=${weight}`}`)\n    }\n\n    return pairs.join(',')\n  }\n}\n", "import { type HeaderValue } from './header-value.ts'\nimport { parseParams } from './param-values.ts'\nimport { isIterable } from './utils.ts'\n\nexport type AcceptEncodingInit = Iterable<string | [string, number]> | Record<string, number>\n\n/**\n * The value of a `Accept-Encoding` HTTP header.\n *\n * [MDN `Accept-Encoding` Reference](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Encoding)\n *\n * [HTTP/1.1 Specification](https://datatracker.ietf.org/doc/html/rfc7231#section-5.3.4)\n */\nexport class AcceptEncoding implements HeaderValue, Iterable<[string, number]> {\n  #map: Map<string, number>\n\n  constructor(init?: string | AcceptEncodingInit) {\n    this.#map = new Map()\n\n    if (init) {\n      if (typeof init === 'string') {\n        for (let piece of init.split(/\\s*,\\s*/)) {\n          let params = parseParams(piece)\n          if (params.length < 1) continue\n\n          let encoding = params[0][0]\n          let weight = 1\n\n          for (let i = 1; i < params.length; i++) {\n            let [key, value] = params[i]\n            if (key === 'q') {\n              weight = Number(value)\n              break\n            }\n          }\n\n          this.#map.set(encoding.toLowerCase(), weight)\n        }\n      } else if (isIterable(init)) {\n        for (let value of init) {\n          if (Array.isArray(value)) {\n            this.#map.set(value[0].toLowerCase(), value[1])\n          } else {\n            this.#map.set(value.toLowerCase(), 1)\n          }\n        }\n      } else {\n        for (let encoding of Object.getOwnPropertyNames(init)) {\n          this.#map.set(encoding.toLowerCase(), init[encoding])\n        }\n      }\n\n      this.#sort()\n    }\n  }\n\n  #sort() {\n    this.#map = new Map([...this.#map].sort((a, b) => b[1] - a[1]))\n  }\n\n  /**\n   * An array of all encodings in the header.\n   */\n  get encodings(): string[] {\n    return Array.from(this.#map.keys())\n  }\n\n  /**\n   * An array of all weights (q values) in the header.\n   */\n  get weights(): number[] {\n    return Array.from(this.#map.values())\n  }\n\n  /**\n   * The number of encodings in the header.\n   */\n  get size(): number {\n    return this.#map.size\n  }\n\n  /**\n   * Returns `true` if the header matches the given encoding (i.e. it is \"acceptable\").\n   * @param encoding The encoding to check.\n   * @returns `true` if the encoding is acceptable, `false` otherwise.\n   */\n  accepts(encoding: string): boolean {\n    return encoding.toLowerCase() === 'identity' || this.getWeight(encoding) > 0\n  }\n\n  /**\n   * Gets the weight an encoding. Performs wildcard matching so `*` matches all encodings.\n   * @param encoding The encoding to get.\n   * @returns The weight of the encoding, or `0` if it is not in the header.\n   */\n  getWeight(encoding: string): number {\n    let lower = encoding.toLowerCase()\n\n    for (let [enc, weight] of this) {\n      if (enc === lower || enc === '*' || lower === '*') {\n        return weight\n      }\n    }\n\n    return 0\n  }\n\n  /**\n   * Returns the most preferred encoding from the given list of encodings.\n   * @param encodings The encodings to choose from.\n   * @returns The most preferred encoding or `null` if none match.\n   */\n  getPreferred(encodings: string[]): string | null {\n    let sorted = encodings\n      .map((encoding) => [encoding, this.getWeight(encoding)] as const)\n      .sort((a, b) => b[1] - a[1])\n\n    let first = sorted[0]\n\n    return first !== undefined && first[1] > 0 ? first[0] : null\n  }\n\n  /**\n   * Gets the weight of an encoding. If it is not in the header verbatim, this returns `null`.\n   * @param encoding The encoding to get.\n   * @returns The weight of the encoding, or `null` if it is not in the header.\n   */\n  get(encoding: string): number | null {\n    return this.#map.get(encoding.toLowerCase()) ?? null\n  }\n\n  /**\n   * Sets an encoding with the given weight.\n   * @param encoding The encoding to set.\n   * @param weight The weight of the encoding. Defaults to 1.\n   */\n  set(encoding: string, weight = 1): void {\n    this.#map.set(encoding.toLowerCase(), weight)\n    this.#sort()\n  }\n\n  /**\n   * Removes the given encoding from the header.\n   * @param encoding The encoding to remove.\n   */\n  delete(encoding: string): void {\n    this.#map.delete(encoding.toLowerCase())\n  }\n\n  /**\n   * Checks if the header contains a given encoding.\n   * @param encoding The encoding to check.\n   * @returns `true` if the encoding is in the header, `false` otherwise.\n   */\n  has(encoding: string): boolean {\n    return this.#map.has(encoding.toLowerCase())\n  }\n\n  /**\n   * Removes all encodings from the header.\n   */\n  clear(): void {\n    this.#map.clear()\n  }\n\n  entries(): IterableIterator<[string, number]> {\n    return this.#map.entries()\n  }\n\n  [Symbol.iterator](): IterableIterator<[string, number]> {\n    return this.entries()\n  }\n\n  forEach(\n    callback: (encoding: string, weight: number, header: AcceptEncoding) => void,\n    thisArg?: any,\n  ): void {\n    for (let [encoding, weight] of this) {\n      callback.call(thisArg, encoding, weight, this)\n    }\n  }\n\n  toString(): string {\n    let pairs: string[] = []\n\n    for (let [encoding, weight] of this.#map) {\n      pairs.push(`${encoding}${weight === 1 ? '' : `;q=${weight}`}`)\n    }\n\n    return pairs.join(',')\n  }\n}\n", "import { type HeaderValue } from './header-value.ts'\nimport { parseParams } from './param-values.ts'\nimport { isIterable } from './utils.ts'\n\nexport type AcceptLanguageInit = Iterable<string | [string, number]> | Record<string, number>\n\n/**\n * The value of a `Accept-Language` HTTP header.\n *\n * [MDN `Accept-Language` Reference](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language)\n *\n * [HTTP/1.1 Specification](https://datatracker.ietf.org/doc/html/rfc7231#section-5.3.5)\n */\nexport class AcceptLanguage implements HeaderValue, Iterable<[string, number]> {\n  #map: Map<string, number>\n\n  constructor(init?: string | AcceptLanguageInit) {\n    this.#map = new Map()\n\n    if (init) {\n      if (typeof init === 'string') {\n        for (let piece of init.split(/\\s*,\\s*/)) {\n          let params = parseParams(piece)\n          if (params.length < 1) continue\n\n          let language = params[0][0]\n          let weight = 1\n\n          for (let i = 1; i < params.length; i++) {\n            let [key, value] = params[i]\n            if (key === 'q') {\n              weight = Number(value)\n              break\n            }\n          }\n\n          this.#map.set(language.toLowerCase(), weight)\n        }\n      } else if (isIterable(init)) {\n        for (let value of init) {\n          if (Array.isArray(value)) {\n            this.#map.set(value[0].toLowerCase(), value[1])\n          } else {\n            this.#map.set(value.toLowerCase(), 1)\n          }\n        }\n      } else {\n        for (let language of Object.getOwnPropertyNames(init)) {\n          this.#map.set(language.toLowerCase(), init[language])\n        }\n      }\n\n      this.#sort()\n    }\n  }\n\n  #sort() {\n    this.#map = new Map([...this.#map].sort((a, b) => b[1] - a[1]))\n  }\n\n  /**\n   * An array of all languages in the header.\n   */\n  get languages(): string[] {\n    return Array.from(this.#map.keys())\n  }\n\n  /**\n   * An array of all weights (q values) in the header.\n   */\n  get weights(): number[] {\n    return Array.from(this.#map.values())\n  }\n\n  /**\n   * The number of languages in the header.\n   */\n  get size(): number {\n    return this.#map.size\n  }\n\n  /**\n   * Returns `true` if the header matches the given language (i.e. it is \"acceptable\").\n   * @param language The locale identifier of the language to check.\n   * @returns `true` if the language is acceptable, `false` otherwise.\n   */\n  accepts(language: string): boolean {\n    return this.getWeight(language) > 0\n  }\n\n  /**\n   * Gets the weight of a language with the given locale identifier. Performs wildcard and subtype\n   * matching, so `en` matches `en-US` and `en-GB`, and `*` matches all languages.\n   * @param language The locale identifier of the language to get.\n   * @returns The weight of the language, or `0` if it is not in the header.\n   */\n  getWeight(language: string): number {\n    let [base, subtype] = language.toLowerCase().split('-')\n\n    for (let [key, value] of this) {\n      let [b, s] = key.split('-')\n      if (\n        (b === base || b === '*' || base === '*') &&\n        (s === subtype || s === undefined || subtype === undefined)\n      ) {\n        return value\n      }\n    }\n\n    return 0\n  }\n\n  /**\n   * Returns the most preferred language from the given list of languages.\n   * @param languages The locale identifiers of the languages to choose from.\n   * @returns The most preferred language or `null` if none match.\n   */\n  getPreferred(languages: string[]): string | null {\n    let sorted = languages\n      .map((language) => [language, this.getWeight(language)] as const)\n      .sort((a, b) => b[1] - a[1])\n\n    let first = sorted[0]\n\n    return first !== undefined && first[1] > 0 ? first[0] : null\n  }\n\n  /**\n   * Gets the weight of a language with the given locale identifier. If it is not in the header\n   * verbatim, this returns `null`.\n   * @param language The locale identifier of the language to get.\n   * @returns The weight of the language, or `null` if it is not in the header.\n   */\n  get(language: string): number | null {\n    return this.#map.get(language.toLowerCase()) ?? null\n  }\n\n  /**\n   * Sets a language with the given weight.\n   * @param language The locale identifier of the language to set.\n   * @param weight The weight of the language. Defaults to 1.\n   */\n  set(language: string, weight = 1): void {\n    this.#map.set(language.toLowerCase(), weight)\n    this.#sort()\n  }\n\n  /**\n   * Removes a language with the given locale identifier.\n   * @param language The locale identifier of the language to remove.\n   */\n  delete(language: string): void {\n    this.#map.delete(language.toLowerCase())\n  }\n\n  /**\n   * Checks if the header contains a language with the given locale identifier.\n   * @param language The locale identifier of the language to check.\n   * @returns `true` if the language is in the header, `false` otherwise.\n   */\n  has(language: string): boolean {\n    return this.#map.has(language.toLowerCase())\n  }\n\n  /**\n   * Removes all languages from the header.\n   */\n  clear(): void {\n    this.#map.clear()\n  }\n\n  entries(): IterableIterator<[string, number]> {\n    return this.#map.entries()\n  }\n\n  [Symbol.iterator](): IterableIterator<[string, number]> {\n    return this.entries()\n  }\n\n  forEach(\n    callback: (language: string, weight: number, header: AcceptLanguage) => void,\n    thisArg?: any,\n  ): void {\n    for (let [language, weight] of this) {\n      callback.call(thisArg, language, weight, this)\n    }\n  }\n\n  toString(): string {\n    let pairs: string[] = []\n\n    for (let [language, weight] of this.#map) {\n      pairs.push(`${language}${weight === 1 ? '' : `;q=${weight}`}`)\n    }\n\n    return pairs.join(',')\n  }\n}\n", "import { type HeaderValue } from './header-value.ts'\nimport { parseParams } from './param-values.ts'\n\n// Taken from https://github.com/jjenzz/pretty-cache-header by jjenzz\n// License: MIT https://github.com/jjenzz/pretty-cache-header/blob/main/LICENSE\nexport interface CacheControlInit {\n  /**\n   * The `max-age=N` **request directive** indicates that the client allows a stored response that\n   * is generated on the origin server within _N_ seconds \u2014 where _N_ may be any non-negative\n   * integer (including `0`).\n   *\n   * The `max-age=N` **response directive** indicates that the response remains\n   * [fresh](https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching#fresh_and_stale_based_on_age)\n   * until _N_ seconds after the response is generated.\n   *\n   * [MDN Reference](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#max-age)\n   */\n  maxAge?: number\n  /**\n   * The `max-stale=N` **request directive** indicates that the client allows a stored response\n   * that is [stale](https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching#fresh_and_stale_based_on_age)\n   * within _N_ seconds.\n   *\n   * [MDN Reference](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#max-stale)\n   */\n  maxStale?: number\n  /**\n   * The `min-fresh=N` **request directive** indicates that the client allows a stored response\n   * that is [fresh](https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching#fresh_and_stale_based_on_age)\n   * for at least _N_ seconds.\n   *\n   * [MDN Reference](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#min-fresh)\n   */\n  minFresh?: number\n  /**\n   * The `s-maxage` **response directive** also indicates how long the response is\n   * [fresh](https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching#fresh_and_stale_based_on_age) for (similar to `max-age`) \u2014\n   * but it is specific to shared caches, and they will ignore `max-age` when it is present.\n   *\n   * [MDN Reference](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#s-maxage)\n   */\n  sMaxage?: number\n  /**\n   * The `no-cache` **request directive** asks caches to validate the response with the origin\n   * server before reuse. If you want caches to always check for content updates while reusing\n   * stored content, `no-cache` is the directive to use.\n   *\n   * The `no-cache` **response directive** indicates that the response can be stored in caches, but\n   * the response must be validated with the origin server before each reuse, even when the cache\n   * is disconnected from the origin server.\n   *\n   * `no-cache` allows clients to request the most up-to-date response even if the cache has a\n   * [fresh](https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching#fresh_and_stale_based_on_age)\n   * response.\n   *\n   * [MDN Reference](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#no-cache)\n   */\n  noCache?: true\n  /**\n   * The `no-store` **request directive** allows a client to request that caches refrain from\n   * storing the request and corresponding response \u2014 even if the origin server's response could\n   * be stored.\n   *\n   * The `no-store` **response directive** indicates that any caches of any kind (private or shared)\n   * should not store this response.\n   *\n   * [MDN Reference](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#no-store)\n   */\n  noStore?: true\n  /**\n   * `no-transform` indicates that any intermediary (regardless of whether it implements a cache)\n   * shouldn't transform the response contents.\n   *\n   * [MDN Reference](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#no-transform)\n   */\n  noTransform?: true\n  /**\n   * The client indicates that cache should obtain an already-cached response. If a cache has\n   * stored a response, it's reused.\n   *\n   * [MDN Reference](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#only-if-cached)\n   */\n  onlyIfCached?: true\n  /**\n   * The `must-revalidate` **response directive** indicates that the response can be stored in\n   * caches and can be reused while [fresh](https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching#fresh_and_stale_based_on_age).\n   * If the response becomes [stale](https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching#fresh_and_stale_based_on_age),\n   * it must be validated with the origin server before reuse.\n   *\n   * [MDN Reference](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#must-revalidate)\n   */\n  mustRevalidate?: true\n  /**\n   * The `proxy-revalidate` **response directive** is the equivalent of `must-revalidate`, but\n   * specifically for shared caches only.\n   *\n   * [MDN Reference](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#proxy-revalidate)\n   */\n  proxyRevalidate?: true\n  /**\n   * The `must-understand` **response directive** indicates that a cache should store the response\n   * only if it understands the requirements for caching based on status code.\n   *\n   * `must-understand` should be coupled with `no-store` for fallback behavior.\n   *\n   * [MDN Reference](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#must-understand)\n   */\n  mustUnderstand?: true\n  /**\n   * The `private` **response directive** indicates that the response can be stored only in a\n   * private cache (e.g. local caches in browsers).\n   *\n   * You should add the `private` directive for user-personalized content, especially for responses\n   * received after login and for sessions managed via cookies.\n   *\n   * [MDN Reference](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#private)\n   */\n  private?: true\n  /**\n   * The `public` **response directive** indicates that the response can be stored in a shared\n   * cache. Responses for requests with `Authorization` header fields must not be stored in a\n   * shared cache; however, the `public` directive will cause such responses to be stored in a\n   * shared cache.\n   *\n   * [MDN Reference](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#public)\n   */\n  public?: true\n  /**\n   * The `immutable` **response directive** indicates that the response will not be updated while\n   * it's [fresh](https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching#fresh_and_stale_based_on_age).\n   *\n   * [MDN Reference](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#public)\n   */\n  immutable?: true\n  /**\n   * The `stale-while-revalidate` **response directive** indicates that the cache could reuse a\n   * stale response while it revalidates it to a cache.\n   *\n   * [MDN Reference](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-while-revalidate)\n   */\n  staleWhileRevalidate?: number\n  /**\n   * The `stale-if-error` **response directive** indicates that the cache can reuse a\n   * [stale response](https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching#fresh_and_stale_based_on_age)\n   * when an upstream server generates an error, or when the error is generated locally. Here, an\n   * error is considered any response with a status code of 500, 502, 503, or 504.\n   *\n   * [MDN Reference](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-if-error)\n   */\n  staleIfError?: number\n}\n\n/**\n * The value of a `Cache-Control` HTTP header.\n *\n * [MDN `Cache-Control` Reference](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control)\n *\n * [HTTP/1.1 Specification](https://datatracker.ietf.org/doc/html/rfc7234#section-5.2)\n */\nexport class CacheControl implements HeaderValue, CacheControlInit {\n  maxAge?: number\n  maxStale?: number\n  minFresh?: number\n  sMaxage?: number\n  noCache?: true\n  noStore?: true\n  noTransform?: true\n  onlyIfCached?: true\n  mustRevalidate?: true\n  proxyRevalidate?: true\n  mustUnderstand?: true\n  private?: true\n  public?: true\n  immutable?: true\n  staleWhileRevalidate?: number\n  staleIfError?: number\n\n  constructor(init?: string | CacheControlInit) {\n    if (init) {\n      if (typeof init === 'string') {\n        let params = parseParams(init, ',')\n        if (params.length > 0) {\n          for (let [name, value] of params) {\n            switch (name) {\n              case 'max-age':\n                this.maxAge = Number(value)\n                break\n              case 'max-stale':\n                this.maxStale = Number(value)\n                break\n              case 'min-fresh':\n                this.minFresh = Number(value)\n                break\n              case 's-maxage':\n                this.sMaxage = Number(value)\n                break\n              case 'no-cache':\n                this.noCache = true\n                break\n              case 'no-store':\n                this.noStore = true\n                break\n              case 'no-transform':\n                this.noTransform = true\n                break\n              case 'only-if-cached':\n                this.onlyIfCached = true\n                break\n              case 'must-revalidate':\n                this.mustRevalidate = true\n                break\n              case 'proxy-revalidate':\n                this.proxyRevalidate = true\n                break\n              case 'must-understand':\n                this.mustUnderstand = true\n                break\n              case 'private':\n                this.private = true\n                break\n              case 'public':\n                this.public = true\n                break\n              case 'immutable':\n                this.immutable = true\n                break\n              case 'stale-while-revalidate':\n                this.staleWhileRevalidate = Number(value)\n                break\n              case 'stale-if-error':\n                this.staleIfError = Number(value)\n                break\n            }\n          }\n        }\n      } else {\n        this.maxAge = init.maxAge\n        this.maxStale = init.maxStale\n        this.minFresh = init.minFresh\n        this.sMaxage = init.sMaxage\n        this.noCache = init.noCache\n        this.noStore = init.noStore\n        this.noTransform = init.noTransform\n        this.onlyIfCached = init.onlyIfCached\n        this.mustRevalidate = init.mustRevalidate\n        this.proxyRevalidate = init.proxyRevalidate\n        this.mustUnderstand = init.mustUnderstand\n        this.private = init.private\n        this.public = init.public\n        this.immutable = init.immutable\n        this.staleWhileRevalidate = init.staleWhileRevalidate\n        this.staleIfError = init.staleIfError\n      }\n    }\n  }\n\n  toString(): string {\n    let parts = []\n\n    if (this.public) {\n      parts.push('public')\n    }\n    if (this.private) {\n      parts.push('private')\n    }\n    if (typeof this.maxAge === 'number') {\n      parts.push(`max-age=${this.maxAge}`)\n    }\n    if (typeof this.sMaxage === 'number') {\n      parts.push(`s-maxage=${this.sMaxage}`)\n    }\n    if (this.noCache) {\n      parts.push('no-cache')\n    }\n    if (this.noStore) {\n      parts.push('no-store')\n    }\n    if (this.noTransform) {\n      parts.push('no-transform')\n    }\n    if (this.onlyIfCached) {\n      parts.push('only-if-cached')\n    }\n    if (this.mustRevalidate) {\n      parts.push('must-revalidate')\n    }\n    if (this.proxyRevalidate) {\n      parts.push('proxy-revalidate')\n    }\n    if (this.mustUnderstand) {\n      parts.push('must-understand')\n    }\n    if (this.immutable) {\n      parts.push('immutable')\n    }\n    if (typeof this.staleWhileRevalidate === 'number') {\n      parts.push(`stale-while-revalidate=${this.staleWhileRevalidate}`)\n    }\n    if (typeof this.staleIfError === 'number') {\n      parts.push(`stale-if-error=${this.staleIfError}`)\n    }\n    if (typeof this.maxStale === 'number') {\n      parts.push(`max-stale=${this.maxStale}`)\n    }\n    if (typeof this.minFresh === 'number') {\n      parts.push(`min-fresh=${this.minFresh}`)\n    }\n\n    return parts.join(', ')\n  }\n}\n", "import { type HeaderValue } from './header-value.ts'\nimport { parseParams, quote } from './param-values.ts'\n\nexport interface ContentDispositionInit {\n  /**\n   * For file uploads, the name of the file that the user selected.\n   */\n  filename?: string\n  /**\n   * For file uploads, the name of the file that the user selected, encoded as a [RFC 8187](https://tools.ietf.org/html/rfc8187) `filename*` parameter.\n   * This parameter allows non-ASCII characters in filenames, and specifies the character encoding.\n   */\n  filenameSplat?: string\n  /**\n   * For `multipart/form-data` requests, the name of the `<input>` field associated with this content.\n   */\n  name?: string\n  /**\n   * The disposition type of the content, such as `attachment` or `inline`.\n   */\n  type?: string\n}\n\n/**\n * The value of a `Content-Disposition` HTTP header.\n *\n * [MDN `Content-Disposition` Reference](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Disposition)\n *\n * [RFC 6266](https://tools.ietf.org/html/rfc6266)\n */\nexport class ContentDisposition implements HeaderValue, ContentDispositionInit {\n  filename?: string\n  filenameSplat?: string\n  name?: string\n  type?: string\n\n  constructor(init?: string | ContentDispositionInit) {\n    if (init) {\n      if (typeof init === 'string') {\n        let params = parseParams(init)\n        if (params.length > 0) {\n          this.type = params[0][0]\n          for (let [name, value] of params.slice(1)) {\n            if (name === 'filename') {\n              this.filename = value\n            } else if (name === 'filename*') {\n              this.filenameSplat = value\n            } else if (name === 'name') {\n              this.name = value\n            }\n          }\n        }\n      } else {\n        this.filename = init.filename\n        this.filenameSplat = init.filenameSplat\n        this.name = init.name\n        this.type = init.type\n      }\n    }\n  }\n\n  /**\n   * The preferred filename for the content, using the `filename*` parameter if present, falling back to the `filename` parameter.\n   *\n   * From [RFC 6266](https://tools.ietf.org/html/rfc6266):\n   *\n   * Many user agent implementations predating this specification do not understand the \"filename*\" parameter.\n   * Therefore, when both \"filename\" and \"filename*\" are present in a single header field value, recipients SHOULD\n   * pick \"filename*\" and ignore \"filename\". This way, senders can avoid special-casing specific user agents by\n   * sending both the more expressive \"filename*\" parameter, and the \"filename\" parameter as fallback for legacy recipients.\n   */\n  get preferredFilename(): string | undefined {\n    let filenameSplat = this.filenameSplat\n    if (filenameSplat) {\n      let decodedFilename = decodeFilenameSplat(filenameSplat)\n      if (decodedFilename) return decodedFilename\n    }\n\n    return this.filename\n  }\n\n  toString(): string {\n    if (!this.type) {\n      return ''\n    }\n\n    let parts = [this.type]\n\n    if (this.name) {\n      parts.push(`name=${quote(this.name)}`)\n    }\n    if (this.filename) {\n      parts.push(`filename=${quote(this.filename)}`)\n    }\n    if (this.filenameSplat) {\n      parts.push(`filename*=${quote(this.filenameSplat)}`)\n    }\n\n    return parts.join('; ')\n  }\n}\n\nfunction decodeFilenameSplat(value: string): string | null {\n  let match = value.match(/^([\\w-]+)'([^']*)'(.+)$/)\n  if (!match) return null\n\n  let [, charset, , encodedFilename] = match\n\n  let decodedFilename = percentDecode(encodedFilename)\n\n  try {\n    let decoder = new TextDecoder(charset)\n    let bytes = new Uint8Array(decodedFilename.split('').map((char) => char.charCodeAt(0)))\n    return decoder.decode(bytes)\n  } catch (error) {\n    console.warn(`Failed to decode filename from charset ${charset}:`, error)\n    return decodedFilename\n  }\n}\n\nfunction percentDecode(value: string): string {\n  return value.replace(/\\+/g, ' ').replace(/%([0-9A-Fa-f]{2})/g, (_, hex) => {\n    return String.fromCharCode(parseInt(hex, 16))\n  })\n}\n", "import { type HeaderValue } from './header-value.ts'\nimport { parseParams, quote } from './param-values.ts'\n\nexport interface ContentTypeInit {\n  /**\n   * For multipart entities, the boundary that separates the different parts of the message.\n   */\n  boundary?: string\n  /**\n   * Indicates the [character encoding](https://developer.mozilla.org/en-US/docs/Glossary/Character_encoding) of the content.\n   *\n   * For example, `utf-8`, `iso-8859-1`.\n   */\n  charset?: string\n  /**\n   * The media type (or MIME type) of the content. This consists of a type and subtype, separated by a slash.\n   *\n   * For example, `text/html`, `application/json`, `image/png`.\n   *\n   * [MDN Reference](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types)\n   */\n  mediaType?: string\n}\n\n/**\n * The value of a `Content-Type` HTTP header.\n *\n * [MDN `Content-Type` Reference](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Type)\n *\n * [HTTP/1.1 Specification](https://datatracker.ietf.org/doc/html/rfc7231#section-3.1.1.5)\n */\nexport class ContentType implements HeaderValue, ContentTypeInit {\n  boundary?: string\n  charset?: string\n  mediaType?: string\n\n  constructor(init?: string | ContentTypeInit) {\n    if (init) {\n      if (typeof init === 'string') {\n        let params = parseParams(init)\n        if (params.length > 0) {\n          this.mediaType = params[0][0]\n          for (let [name, value] of params.slice(1)) {\n            if (name === 'boundary') {\n              this.boundary = value\n            } else if (name === 'charset') {\n              this.charset = value\n            }\n          }\n        }\n      } else {\n        this.boundary = init.boundary\n        this.charset = init.charset\n        this.mediaType = init.mediaType\n      }\n    }\n  }\n\n  toString(): string {\n    if (!this.mediaType) {\n      return ''\n    }\n\n    let parts = [this.mediaType]\n\n    if (this.charset) {\n      parts.push(`charset=${quote(this.charset)}`)\n    }\n    if (this.boundary) {\n      parts.push(`boundary=${quote(this.boundary)}`)\n    }\n\n    return parts.join('; ')\n  }\n}\n", "import { type HeaderValue } from './header-value.ts'\nimport { parseParams, quote } from './param-values.ts'\nimport { isIterable } from './utils.ts'\n\nexport type CookieInit = Iterable<[string, string]> | Record<string, string>\n\n/**\n * The value of a `Cookie` HTTP header.\n *\n * [MDN `Cookie` Reference](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cookie)\n *\n * [HTTP/1.1 Specification](https://datatracker.ietf.org/doc/html/rfc6265#section-4.2)\n */\nexport class Cookie implements HeaderValue, Iterable<[string, string]> {\n  #map: Map<string, string>\n\n  constructor(init?: string | CookieInit) {\n    this.#map = new Map()\n    if (init) {\n      if (typeof init === 'string') {\n        let params = parseParams(init)\n        for (let [name, value] of params) {\n          this.#map.set(name, value ?? '')\n        }\n      } else if (isIterable(init)) {\n        for (let [name, value] of init) {\n          this.#map.set(name, value)\n        }\n      } else {\n        for (let name of Object.getOwnPropertyNames(init)) {\n          this.#map.set(name, init[name])\n        }\n      }\n    }\n  }\n\n  /**\n   * An array of the names of the cookies in the header.\n   */\n  get names(): string[] {\n    return Array.from(this.#map.keys())\n  }\n\n  /**\n   * An array of the values of the cookies in the header.\n   */\n  get values(): string[] {\n    return Array.from(this.#map.values())\n  }\n\n  /**\n   * The number of cookies in the header.\n   */\n  get size(): number {\n    return this.#map.size\n  }\n\n  /**\n   * Gets the value of a cookie with the given name from the header.\n   * @param name The name of the cookie.\n   * @returns The value of the cookie, or `null` if the cookie does not exist.\n   */\n  get(name: string): string | null {\n    return this.#map.get(name) ?? null\n  }\n\n  /**\n   * Sets a cookie with the given name and value in the header.\n   * @param name The name of the cookie.\n   * @param value The value of the cookie.\n   */\n  set(name: string, value: string): void {\n    this.#map.set(name, value)\n  }\n\n  /**\n   * Removes a cookie with the given name from the header.\n   * @param name The name of the cookie.\n   */\n  delete(name: string): void {\n    this.#map.delete(name)\n  }\n\n  /**\n   * True if a cookie with the given name exists in the header.\n   * @param name The name of the cookie.\n   * @returns True if a cookie with the given name exists in the header.\n   */\n  has(name: string): boolean {\n    return this.#map.has(name)\n  }\n\n  /**\n   * Removes all cookies from the header.\n   */\n  clear(): void {\n    this.#map.clear()\n  }\n\n  entries(): IterableIterator<[string, string]> {\n    return this.#map.entries()\n  }\n\n  [Symbol.iterator](): IterableIterator<[string, string]> {\n    return this.entries()\n  }\n\n  forEach(callback: (name: string, value: string, header: Cookie) => void, thisArg?: any): void {\n    for (let [name, value] of this) {\n      callback.call(thisArg, name, value, this)\n    }\n  }\n\n  toString(): string {\n    let pairs: string[] = []\n\n    for (let [name, value] of this.#map) {\n      pairs.push(`${name}=${quote(value)}`)\n    }\n\n    return pairs.join('; ')\n  }\n}\n", "import { type HeaderValue } from './header-value.ts'\nimport { quoteEtag } from './utils.ts'\n\nexport interface IfNoneMatchInit {\n  /**\n   * The entity tags to compare against the current entity.\n   */\n  tags: string[]\n}\n\n/**\n * The value of an `If-None-Match` HTTP header.\n *\n * [MDN `If-None-Match` Reference](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-None-Match)\n *\n * [HTTP/1.1 Specification](https://datatracker.ietf.org/doc/html/rfc7232#section-3.2)\n */\nexport class IfNoneMatch implements HeaderValue, IfNoneMatchInit {\n  tags: string[] = []\n\n  constructor(init?: string | string[] | IfNoneMatchInit) {\n    if (init) {\n      if (typeof init === 'string') {\n        this.tags.push(...init.split(/\\s*,\\s*/).map(quoteEtag))\n      } else if (Array.isArray(init)) {\n        this.tags.push(...init.map(quoteEtag))\n      } else {\n        this.tags.push(...init.tags.map(quoteEtag))\n      }\n    }\n  }\n\n  /**\n   * Checks if the header contains the given entity tag.\n   *\n   * Note: This method checks only for exact matches and does not consider wildcards.\n   *\n   * @param tag The entity tag to check for.\n   * @returns `true` if the tag is present in the header, `false` otherwise.\n   */\n  has(tag: string): boolean {\n    return this.tags.includes(quoteEtag(tag))\n  }\n\n  /**\n   * Checks if this header matches the given entity tag.\n   *\n   * @param tag The entity tag to check for.\n   * @returns `true` if the tag is present in the header (or the header contains a wildcard), `false` otherwise.\n   */\n  matches(tag: string): boolean {\n    return this.has(tag) || this.tags.includes('*')\n  }\n\n  toString() {\n    return this.tags.join(', ')\n  }\n}\n", "import { type HeaderValue } from './header-value.ts'\nimport { parseParams, quote } from './param-values.ts'\nimport { capitalize, isValidDate } from './utils.ts'\n\ntype SameSiteValue = 'Strict' | 'Lax' | 'None'\n\nexport interface SetCookieInit {\n  /**\n   * The domain of the cookie. For example, `example.com`.\n   *\n   * [MDN Reference](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#domaindomain-value)\n   */\n  domain?: string\n  /**\n   * The expiration date of the cookie. If not specified, the cookie is a session cookie.\n   *\n   * [MDN Reference](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#expiresdate)\n   */\n  expires?: Date\n  /**\n   * Indicates this cookie should not be accessible via JavaScript.\n   *\n   * [MDN Reference](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#httponly)\n   */\n  httpOnly?: true\n  /**\n   * The maximum age of the cookie in seconds.\n   *\n   * [MDN Reference](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#max-age)\n   */\n  maxAge?: number\n  /**\n   * The name of the cookie.\n   *\n   * [MDN Reference](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#cookie-namecookie-value)\n   */\n  name?: string\n  /**\n   * The path of the cookie. For example, `/` or `/admin`.\n   *\n   * [MDN Reference](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#pathpath-value)\n   */\n  path?: string\n  /**\n   * The `SameSite` attribute of the cookie. This attribute lets servers require that a cookie shouldn't be sent with\n   * cross-site requests, which provides some protection against cross-site request forgery attacks.\n   *\n   * [MDN Reference](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#samesitesamesite-value)\n   */\n  sameSite?: SameSiteValue\n  /**\n   * Indicates the cookie should only be sent over HTTPS.\n   *\n   * [MDN Reference](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#secure)\n   */\n  secure?: true\n  /**\n   * The value of the cookie.\n   *\n   * [MDN Reference](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#cookie-namecookie-value)\n   */\n  value?: string\n}\n\n/**\n * The value of a `Set-Cookie` HTTP header.\n *\n * [MDN `Set-Cookie` Reference](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie)\n *\n * [HTTP/1.1 Specification](https://datatracker.ietf.org/doc/html/rfc6265#section-4.1)\n */\nexport class SetCookie implements HeaderValue, SetCookieInit {\n  domain?: string\n  expires?: Date\n  httpOnly?: true\n  maxAge?: number\n  name?: string\n  path?: string\n  sameSite?: SameSiteValue\n  secure?: true\n  value?: string\n\n  constructor(init?: string | SetCookieInit) {\n    if (init) {\n      if (typeof init === 'string') {\n        let params = parseParams(init)\n        if (params.length > 0) {\n          this.name = params[0][0]\n          this.value = params[0][1]\n\n          for (let [key, value] of params.slice(1)) {\n            switch (key.toLowerCase()) {\n              case 'domain':\n                this.domain = value\n                break\n              case 'expires': {\n                if (typeof value === 'string') {\n                  let date = new Date(value)\n                  if (isValidDate(date)) {\n                    this.expires = date\n                  }\n                }\n                break\n              }\n              case 'httponly':\n                this.httpOnly = true\n                break\n              case 'max-age': {\n                if (typeof value === 'string') {\n                  let v = parseInt(value, 10)\n                  if (!isNaN(v)) this.maxAge = v\n                }\n                break\n              }\n              case 'path':\n                this.path = value\n                break\n              case 'samesite':\n                if (typeof value === 'string' && /strict|lax|none/i.test(value)) {\n                  this.sameSite = capitalize(value) as SameSiteValue\n                }\n                break\n              case 'secure':\n                this.secure = true\n                break\n            }\n          }\n        }\n      } else {\n        this.domain = init.domain\n        this.expires = init.expires\n        this.httpOnly = init.httpOnly\n        this.maxAge = init.maxAge\n        this.name = init.name\n        this.path = init.path\n        this.sameSite = init.sameSite\n        this.secure = init.secure\n        this.value = init.value\n      }\n    }\n  }\n\n  toString(): string {\n    if (!this.name) {\n      return ''\n    }\n\n    let parts = [`${this.name}=${quote(this.value || '')}`]\n\n    if (this.domain) {\n      parts.push(`Domain=${this.domain}`)\n    }\n    if (this.path) {\n      parts.push(`Path=${this.path}`)\n    }\n    if (this.expires) {\n      parts.push(`Expires=${this.expires.toUTCString()}`)\n    }\n    if (this.maxAge) {\n      parts.push(`Max-Age=${this.maxAge}`)\n    }\n    if (this.secure) {\n      parts.push('Secure')\n    }\n    if (this.httpOnly) {\n      parts.push('HttpOnly')\n    }\n    if (this.sameSite) {\n      parts.push(`SameSite=${this.sameSite}`)\n    }\n\n    return parts.join('; ')\n  }\n}\n", "const HeaderWordCasingExceptions: Record<string, string> = {\n  ct: 'CT',\n  etag: 'ETag',\n  te: 'TE',\n  www: 'WWW',\n  x: 'X',\n  xss: 'XSS',\n}\n\nexport function canonicalHeaderName(name: string): string {\n  return name\n    .toLowerCase()\n    .split('-')\n    .map((word) => HeaderWordCasingExceptions[word] || word.charAt(0).toUpperCase() + word.slice(1))\n    .join('-')\n}\n", "import { type AcceptInit, Accept } from './accept.ts'\nimport { type AcceptEncodingInit, AcceptEncoding } from './accept-encoding.ts'\nimport { type AcceptLanguageInit, AcceptLanguage } from './accept-language.ts'\nimport { type CacheControlInit, CacheControl } from './cache-control.ts'\nimport { type ContentDispositionInit, ContentDisposition } from './content-disposition.ts'\nimport { type ContentTypeInit, ContentType } from './content-type.ts'\nimport { type CookieInit, Cookie } from './cookie.ts'\nimport { canonicalHeaderName } from './header-names.ts'\nimport { type HeaderValue } from './header-value.ts'\nimport { type IfNoneMatchInit, IfNoneMatch } from './if-none-match.ts'\nimport { type SetCookieInit, SetCookie } from './set-cookie.ts'\nimport { isIterable, quoteEtag } from './utils.ts'\n\ntype DateInit = number | Date\n\ninterface SuperHeadersPropertyInit {\n  /**\n   * The [`Accept`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept) header value.\n   */\n  accept?: string | AcceptInit\n  /**\n   * The [`Accept-Encoding`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Encoding) header value.\n   */\n  acceptEncoding?: string | AcceptEncodingInit\n  /**\n   * The [`Accept-Language`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language) header value.\n   */\n  acceptLanguage?: string | AcceptLanguageInit\n  /**\n   * The [`Accept-Ranges`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Ranges) header value.\n   */\n  acceptRanges?: string\n  /**\n   * The [`Age`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Age) header value.\n   */\n  age?: string | number\n  /**\n   * The [`Cache-Control`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control) header value.\n   */\n  cacheControl?: string | CacheControlInit\n  /**\n   * The [`Connection`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Connection) header value.\n   */\n  connection?: string\n  /**\n   * The [`Content-Disposition`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Disposition) header value.\n   */\n  contentDisposition?: string | ContentDispositionInit\n  /**\n   * The [`Content-Encoding`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Encoding) header value.\n   */\n  contentEncoding?: string | string[]\n  /**\n   * The [`Content-Language`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Language) header value.\n   */\n  contentLanguage?: string | string[]\n  /**\n   * The [`Content-Length`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Length) header value.\n   */\n  contentLength?: string | number\n  /**\n   * The [`Content-Type`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Type) header value.\n   */\n  contentType?: string | ContentTypeInit\n  /**\n   * The [`Cookie`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cookie) header value.\n   */\n  cookie?: string | CookieInit\n  /**\n   * The [`Date`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Date) header value.\n   */\n  date?: string | DateInit\n  /**\n   * The [`ETag`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag) header value.\n   */\n  etag?: string\n  /**\n   * The [`Expires`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Expires) header value.\n   */\n  expires?: string | DateInit\n  /**\n   * The [`Host`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Host) header value.\n   */\n  host?: string\n  /**\n   * The [`If-Modified-Since`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-Modified-Since) header value.\n   */\n  ifModifiedSince?: string | DateInit\n  /**\n   * The [`If-None-Match`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-None-Match) header value.\n   */\n  ifNoneMatch?: string | string[] | IfNoneMatchInit\n  /**\n   * The [`If-Unmodified-Since`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-Unmodified-Since) header value.\n   */\n  ifUnmodifiedSince?: string | DateInit\n  /**\n   * The [`Last-Modified`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Last-Modified) header value.\n   */\n  lastModified?: string | DateInit\n  /**\n   * The [`Location`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Location) header value.\n   */\n  location?: string\n  /**\n   * The [`Referer`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referer) header value.\n   */\n  referer?: string\n  /**\n   * The [`Set-Cookie`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie) header value(s).\n   */\n  setCookie?: string | (string | SetCookieInit)[]\n}\n\nexport type SuperHeadersInit =\n  | Iterable<[string, string]>\n  | (SuperHeadersPropertyInit & Record<string, string | HeaderValue>)\n\nconst CRLF = '\\r\\n'\n\nconst AcceptKey = 'accept'\nconst AcceptEncodingKey = 'accept-encoding'\nconst AcceptLanguageKey = 'accept-language'\nconst AcceptRangesKey = 'accept-ranges'\nconst AgeKey = 'age'\nconst CacheControlKey = 'cache-control'\nconst ConnectionKey = 'connection'\nconst ContentDispositionKey = 'content-disposition'\nconst ContentEncodingKey = 'content-encoding'\nconst ContentLanguageKey = 'content-language'\nconst ContentLengthKey = 'content-length'\nconst ContentTypeKey = 'content-type'\nconst CookieKey = 'cookie'\nconst DateKey = 'date'\nconst ETagKey = 'etag'\nconst ExpiresKey = 'expires'\nconst HostKey = 'host'\nconst IfModifiedSinceKey = 'if-modified-since'\nconst IfNoneMatchKey = 'if-none-match'\nconst IfUnmodifiedSinceKey = 'if-unmodified-since'\nconst LastModifiedKey = 'last-modified'\nconst LocationKey = 'location'\nconst RefererKey = 'referer'\nconst SetCookieKey = 'set-cookie'\n\n/**\n * An enhanced JavaScript `Headers` interface with type-safe access.\n *\n * [API Reference](https://github.com/remix-run/remix/tree/main/packages/headers)\n *\n * [MDN `Headers` Base Class Reference](https://developer.mozilla.org/en-US/docs/Web/API/Headers)\n */\nexport class SuperHeaders extends Headers {\n  #map: Map<string, string | HeaderValue>\n  #setCookies: (string | SetCookie)[] = []\n\n  constructor(init?: string | SuperHeadersInit | Headers) {\n    super()\n\n    this.#map = new Map()\n\n    if (init) {\n      if (typeof init === 'string') {\n        let lines = init.split(CRLF)\n        for (let line of lines) {\n          let match = line.match(/^([^:]+):(.*)/)\n          if (match) {\n            this.append(match[1].trim(), match[2].trim())\n          }\n        }\n      } else if (isIterable(init)) {\n        for (let [name, value] of init) {\n          this.append(name, value)\n        }\n      } else if (typeof init === 'object') {\n        for (let name of Object.getOwnPropertyNames(init)) {\n          let value = init[name]\n\n          let descriptor = Object.getOwnPropertyDescriptor(SuperHeaders.prototype, name)\n          if (descriptor?.set) {\n            descriptor.set.call(this, value)\n          } else {\n            this.set(name, value.toString())\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Appends a new header value to the existing set of values for a header,\n   * or adds the header if it does not already exist.\n   *\n   * [MDN Reference](https://developer.mozilla.org/en-US/docs/Web/API/Headers/append)\n   */\n  append(name: string, value: string): void {\n    let key = name.toLowerCase()\n    if (key === SetCookieKey) {\n      this.#setCookies.push(value)\n    } else {\n      let existingValue = this.#map.get(key)\n      this.#map.set(key, existingValue ? `${existingValue}, ${value}` : value)\n    }\n  }\n\n  /**\n   * Removes a header.\n   *\n   * [MDN Reference](https://developer.mozilla.org/en-US/docs/Web/API/Headers/delete)\n   */\n  delete(name: string): void {\n    let key = name.toLowerCase()\n    if (key === SetCookieKey) {\n      this.#setCookies = []\n    } else {\n      this.#map.delete(key)\n    }\n  }\n\n  /**\n   * Returns a string of all the values for a header, or `null` if the header does not exist.\n   *\n   * [MDN Reference](https://developer.mozilla.org/en-US/docs/Web/API/Headers/get)\n   */\n  get(name: string): string | null {\n    let key = name.toLowerCase()\n    if (key === SetCookieKey) {\n      return this.getSetCookie().join(', ')\n    } else {\n      let value = this.#map.get(key)\n      if (typeof value === 'string') {\n        return value\n      } else if (value != null) {\n        let str = value.toString()\n        return str === '' ? null : str\n      } else {\n        return null\n      }\n    }\n  }\n\n  /**\n   * Returns an array of all values associated with the `Set-Cookie` header. This is\n   * useful when building headers for a HTTP response since multiple `Set-Cookie` headers\n   * must be sent on separate lines.\n   *\n   * [MDN Reference](https://developer.mozilla.org/en-US/docs/Web/API/Headers/getSetCookie)\n   */\n  getSetCookie(): string[] {\n    return this.#setCookies.map((v) => (typeof v === 'string' ? v : v.toString()))\n  }\n\n  /**\n   * Returns `true` if the header is present in the list of headers.\n   *\n   * [MDN Reference](https://developer.mozilla.org/en-US/docs/Web/API/Headers/has)\n   */\n  has(name: string): boolean {\n    let key = name.toLowerCase()\n    return key === SetCookieKey ? this.#setCookies.length > 0 : this.get(key) != null\n  }\n\n  /**\n   * Sets a new value for the given header. If the header already exists, the new value\n   * will replace the existing value.\n   *\n   * [MDN Reference](https://developer.mozilla.org/en-US/docs/Web/API/Headers/set)\n   */\n  set(name: string, value: string): void {\n    let key = name.toLowerCase()\n    if (key === SetCookieKey) {\n      this.#setCookies = [value]\n    } else {\n      this.#map.set(key, value)\n    }\n  }\n\n  /**\n   * Returns an iterator of all header keys (lowercase).\n   *\n   * [MDN Reference](https://developer.mozilla.org/en-US/docs/Web/API/Headers/keys)\n   */\n  *keys(): HeadersIterator<string> {\n    for (let [key] of this) yield key\n  }\n\n  /**\n   * Returns an iterator of all header values.\n   *\n   * [MDN Reference](https://developer.mozilla.org/en-US/docs/Web/API/Headers/values)\n   */\n  *values(): HeadersIterator<string> {\n    for (let [, value] of this) yield value\n  }\n\n  /**\n   * Returns an iterator of all header key/value pairs.\n   *\n   * [MDN Reference](https://developer.mozilla.org/en-US/docs/Web/API/Headers/entries)\n   */\n  *entries(): HeadersIterator<[string, string]> {\n    for (let [key] of this.#map) {\n      let str = this.get(key)\n      if (str) yield [key, str]\n    }\n\n    for (let value of this.getSetCookie()) {\n      yield [SetCookieKey, value]\n    }\n  }\n\n  [Symbol.iterator](): HeadersIterator<[string, string]> {\n    return this.entries()\n  }\n\n  /**\n   * Invokes the `callback` for each header key/value pair.\n   *\n   * [MDN Reference](https://developer.mozilla.org/en-US/docs/Web/API/Headers/forEach)\n   */\n  forEach(callback: (value: string, key: string, parent: Headers) => void, thisArg?: any): void {\n    for (let [key, value] of this) {\n      callback.call(thisArg, value, key, this)\n    }\n  }\n\n  /**\n   * Returns a string representation of the headers suitable for use in a HTTP message.\n   */\n  toString(): string {\n    let lines: string[] = []\n\n    for (let [key, value] of this) {\n      lines.push(`${canonicalHeaderName(key)}: ${value}`)\n    }\n\n    return lines.join(CRLF)\n  }\n\n  // Header-specific getters and setters\n\n  /**\n   * The `Accept` header is used by clients to indicate the media types that are acceptable\n   * in the response.\n   *\n   * [MDN `Accept` Reference](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept)\n   *\n   * [HTTP/1.1 Specification](https://datatracker.ietf.org/doc/html/rfc7231#section-5.3.2)\n   */\n  get accept(): Accept {\n    return this.#getHeaderValue(AcceptKey, Accept)\n  }\n\n  set accept(value: string | AcceptInit | undefined | null) {\n    this.#setHeaderValue(AcceptKey, Accept, value)\n  }\n\n  /**\n   * The `Accept-Encoding` header contains information about the content encodings that the client\n   * is willing to accept in the response.\n   *\n   * [MDN `Accept-Encoding` Reference](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Encoding)\n   *\n   * [HTTP/1.1 Specification](https://datatracker.ietf.org/doc/html/rfc7231#section-5.3.4)\n   */\n  get acceptEncoding(): AcceptEncoding {\n    return this.#getHeaderValue(AcceptEncodingKey, AcceptEncoding)\n  }\n\n  set acceptEncoding(value: string | AcceptEncodingInit | undefined | null) {\n    this.#setHeaderValue(AcceptEncodingKey, AcceptEncoding, value)\n  }\n\n  /**\n   * The `Accept-Language` header contains information about preferred natural language for the\n   * response.\n   *\n   * [MDN `Accept-Language` Reference](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language)\n   *\n   * [HTTP/1.1 Specification](https://datatracker.ietf.org/doc/html/rfc7231#section-5.3.5)\n   */\n  get acceptLanguage(): AcceptLanguage {\n    return this.#getHeaderValue(AcceptLanguageKey, AcceptLanguage)\n  }\n\n  set acceptLanguage(value: string | AcceptLanguageInit | undefined | null) {\n    this.#setHeaderValue(AcceptLanguageKey, AcceptLanguage, value)\n  }\n\n  /**\n   * The `Accept-Ranges` header indicates the server's acceptance of range requests.\n   *\n   * [MDN `Accept-Ranges` Reference](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Ranges)\n   *\n   * [HTTP/1.1 Specification](https://datatracker.ietf.org/doc/html/rfc7233#section-2.3)\n   */\n  get acceptRanges(): string | null {\n    return this.#getStringValue(AcceptRangesKey)\n  }\n\n  set acceptRanges(value: string | undefined | null) {\n    this.#setStringValue(AcceptRangesKey, value)\n  }\n\n  /**\n   * The `Age` header contains the time in seconds an object was in a proxy cache.\n   *\n   * [MDN `Age` Reference](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Age)\n   *\n   * [HTTP/1.1 Specification](https://datatracker.ietf.org/doc/html/rfc7234#section-5.1)\n   */\n  get age(): number | null {\n    return this.#getNumberValue(AgeKey)\n  }\n\n  set age(value: string | number | undefined | null) {\n    this.#setNumberValue(AgeKey, value)\n  }\n\n  /**\n   * The `Cache-Control` header contains directives for caching mechanisms in both requests and responses.\n   *\n   * [MDN `Cache-Control` Reference](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control)\n   *\n   * [HTTP/1.1 Specification](https://datatracker.ietf.org/doc/html/rfc7234#section-5.2)\n   */\n  get cacheControl(): CacheControl {\n    return this.#getHeaderValue(CacheControlKey, CacheControl)\n  }\n\n  set cacheControl(value: string | CacheControlInit | undefined | null) {\n    this.#setHeaderValue(CacheControlKey, CacheControl, value)\n  }\n\n  /**\n   * The `Connection` header controls whether the network connection stays open after the current\n   * transaction finishes.\n   *\n   * [MDN `Connection` Reference](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Connection)\n   *\n   * [HTTP/1.1 Specification](https://datatracker.ietf.org/doc/html/rfc7230#section-6.1)\n   */\n  get connection(): string | null {\n    return this.#getStringValue(ConnectionKey)\n  }\n\n  set connection(value: string | undefined | null) {\n    this.#setStringValue(ConnectionKey, value)\n  }\n\n  /**\n   * The `Content-Disposition` header is a response-type header that describes how the payload is displayed.\n   *\n   * [MDN `Content-Disposition` Reference](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Disposition)\n   *\n   * [RFC 6266](https://datatracker.ietf.org/doc/html/rfc6266)\n   */\n  get contentDisposition(): ContentDisposition {\n    return this.#getHeaderValue(ContentDispositionKey, ContentDisposition)\n  }\n\n  set contentDisposition(value: string | ContentDispositionInit | undefined | null) {\n    this.#setHeaderValue(ContentDispositionKey, ContentDisposition, value)\n  }\n\n  /**\n   * The `Content-Encoding` header specifies the encoding of the resource.\n   *\n   * Note: If multiple encodings have been used, this value may be a comma-separated list. However, most often this\n   * header will only contain a single value.\n   *\n   * [MDN `Content-Encoding` Reference](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Encoding)\n   *\n   * [HTTP/1.1 Specification](https://httpwg.org/specs/rfc9110.html#field.content-encoding)\n   */\n  get contentEncoding(): string | null {\n    return this.#getStringValue(ContentEncodingKey)\n  }\n\n  set contentEncoding(value: string | string[] | undefined | null) {\n    this.#setStringValue(ContentEncodingKey, Array.isArray(value) ? value.join(', ') : value)\n  }\n\n  /**\n   * The `Content-Language` header describes the natural language(s) of the intended audience for the response content.\n   *\n   * Note: If the response content is intended for multiple audiences, this value may be a comma-separated list. However,\n   * most often this header will only contain a single value.\n   *\n   * [MDN `Content-Language` Reference](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Language)\n   *\n   * [HTTP/1.1 Specification](https://httpwg.org/specs/rfc9110.html#field.content-language)\n   */\n  get contentLanguage(): string | null {\n    return this.#getStringValue(ContentLanguageKey)\n  }\n\n  set contentLanguage(value: string | string[] | undefined | null) {\n    this.#setStringValue(ContentLanguageKey, Array.isArray(value) ? value.join(', ') : value)\n  }\n\n  /**\n   * The `Content-Length` header indicates the size of the entity-body in bytes.\n   *\n   * [MDN `Content-Length` Reference](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Length)\n   *\n   * [HTTP/1.1 Specification](https://datatracker.ietf.org/doc/html/rfc7230#section-3.3.2)\n   */\n  get contentLength(): number | null {\n    return this.#getNumberValue(ContentLengthKey)\n  }\n\n  set contentLength(value: string | number | undefined | null) {\n    this.#setNumberValue(ContentLengthKey, value)\n  }\n\n  /**\n   * The `Content-Type` header indicates the media type of the resource.\n   *\n   * [MDN `Content-Type` Reference](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Type)\n   *\n   * [HTTP/1.1 Specification](https://datatracker.ietf.org/doc/html/rfc7231#section-3.1.1.5)\n   */\n  get contentType(): ContentType {\n    return this.#getHeaderValue(ContentTypeKey, ContentType)\n  }\n\n  set contentType(value: string | ContentTypeInit | undefined | null) {\n    this.#setHeaderValue(ContentTypeKey, ContentType, value)\n  }\n\n  /**\n   * The `Cookie` request header contains stored HTTP cookies previously sent by the server with\n   * the `Set-Cookie` header.\n   *\n   * [MDN `Cookie` Reference](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cookie)\n   *\n   * [HTTP/1.1 Specification](https://datatracker.ietf.org/doc/html/rfc6265#section-5.4)\n   */\n  get cookie(): Cookie {\n    return this.#getHeaderValue(CookieKey, Cookie)\n  }\n\n  set cookie(value: string | CookieInit | undefined | null) {\n    this.#setHeaderValue(CookieKey, Cookie, value)\n  }\n\n  /**\n   * The `Date` header contains the date and time at which the message was sent.\n   *\n   * [MDN `Date` Reference](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Date)\n   *\n   * [HTTP/1.1 Specification](https://datatracker.ietf.org/doc/html/rfc7231#section-7.1.1.2)\n   */\n  get date(): Date | null {\n    return this.#getDateValue(DateKey)\n  }\n\n  set date(value: string | DateInit | undefined | null) {\n    this.#setDateValue(DateKey, value)\n  }\n\n  /**\n   * The `ETag` header provides a unique identifier for the current version of the resource.\n   *\n   * [MDN `ETag` Reference](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag)\n   *\n   * [HTTP/1.1 Specification](https://datatracker.ietf.org/doc/html/rfc7232#section-2.3)\n   */\n  get etag(): string | null {\n    return this.#getStringValue(ETagKey)\n  }\n\n  set etag(value: string | undefined | null) {\n    this.#setStringValue(ETagKey, typeof value === 'string' ? quoteEtag(value) : value)\n  }\n\n  /**\n   * The `Expires` header contains the date/time after which the response is considered stale.\n   *\n   * [MDN `Expires` Reference](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Expires)\n   *\n   * [HTTP/1.1 Specification](https://datatracker.ietf.org/doc/html/rfc7234#section-5.3)\n   */\n  get expires(): Date | null {\n    return this.#getDateValue(ExpiresKey)\n  }\n\n  set expires(value: string | DateInit | undefined | null) {\n    this.#setDateValue(ExpiresKey, value)\n  }\n\n  /**\n   * The `Host` header specifies the domain name of the server and (optionally) the TCP port number.\n   *\n   * [MDN `Host` Reference](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Host)\n   *\n   * [HTTP/1.1 Specification](https://datatracker.ietf.org/doc/html/rfc7230#section-5.4)\n   */\n  get host(): string | null {\n    return this.#getStringValue(HostKey)\n  }\n\n  set host(value: string | undefined | null) {\n    this.#setStringValue(HostKey, value)\n  }\n\n  /**\n   * The `If-Modified-Since` header makes a request conditional on the last modification date of the\n   * requested resource.\n   *\n   * [MDN `If-Modified-Since` Reference](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-Modified-Since)\n   *\n   * [HTTP/1.1 Specification](https://datatracker.ietf.org/doc/html/rfc7232#section-3.3)\n   */\n  get ifModifiedSince(): Date | null {\n    return this.#getDateValue(IfModifiedSinceKey)\n  }\n\n  set ifModifiedSince(value: string | DateInit | undefined | null) {\n    this.#setDateValue(IfModifiedSinceKey, value)\n  }\n\n  /**\n   * The `If-None-Match` header makes a request conditional on the absence of a matching ETag.\n   *\n   * [MDN `If-None-Match` Reference](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-None-Match)\n   *\n   * [HTTP/1.1 Specification](https://datatracker.ietf.org/doc/html/rfc7232#section-3.2)\n   */\n  get ifNoneMatch(): IfNoneMatch {\n    return this.#getHeaderValue(IfNoneMatchKey, IfNoneMatch)\n  }\n\n  set ifNoneMatch(value: string | string[] | IfNoneMatchInit | undefined | null) {\n    this.#setHeaderValue(IfNoneMatchKey, IfNoneMatch, value)\n  }\n\n  /**\n   * The `If-Unmodified-Since` header makes a request conditional on the last modification date of the\n   * requested resource.\n   *\n   * [MDN `If-Unmodified-Since` Reference](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-Unmodified-Since)\n   *\n   * [HTTP/1.1 Specification](https://datatracker.ietf.org/doc/html/rfc7232#section-3.4)\n   */\n  get ifUnmodifiedSince(): Date | null {\n    return this.#getDateValue(IfUnmodifiedSinceKey)\n  }\n\n  set ifUnmodifiedSince(value: string | DateInit | undefined | null) {\n    this.#setDateValue(IfUnmodifiedSinceKey, value)\n  }\n\n  /**\n   * The `Last-Modified` header contains the date and time at which the resource was last modified.\n   *\n   * [MDN `Last-Modified` Reference](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Last-Modified)\n   *\n   * [HTTP/1.1 Specification](https://datatracker.ietf.org/doc/html/rfc7232#section-2.2)\n   */\n  get lastModified(): Date | null {\n    return this.#getDateValue(LastModifiedKey)\n  }\n\n  set lastModified(value: string | DateInit | undefined | null) {\n    this.#setDateValue(LastModifiedKey, value)\n  }\n\n  /**\n   * The `Location` header indicates the URL to redirect to.\n   *\n   * [MDN `Location` Reference](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Location)\n   *\n   * [HTTP/1.1 Specification](https://datatracker.ietf.org/doc/html/rfc7231#section-7.1.2)\n   */\n  get location(): string | null {\n    return this.#getStringValue(LocationKey)\n  }\n\n  set location(value: string | undefined | null) {\n    this.#setStringValue(LocationKey, value)\n  }\n\n  /**\n   * The `Referer` header contains the address of the previous web page from which a link to the\n   * currently requested page was followed.\n   *\n   * [MDN `Referer` Reference](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referer)\n   *\n   * [HTTP/1.1 Specification](https://datatracker.ietf.org/doc/html/rfc7231#section-5.5.2)\n   */\n  get referer(): string | null {\n    return this.#getStringValue(RefererKey)\n  }\n\n  set referer(value: string | undefined | null) {\n    this.#setStringValue(RefererKey, value)\n  }\n\n  /**\n   * The `Set-Cookie` header is used to send cookies from the server to the user agent.\n   *\n   * [MDN `Set-Cookie` Reference](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie)\n   *\n   * [HTTP/1.1 Specification](https://datatracker.ietf.org/doc/html/rfc6265#section-4.1)\n   */\n  get setCookie(): SetCookie[] {\n    let setCookies = this.#setCookies\n\n    for (let i = 0; i < setCookies.length; ++i) {\n      if (typeof setCookies[i] === 'string') {\n        setCookies[i] = new SetCookie(setCookies[i])\n      }\n    }\n\n    return setCookies as SetCookie[]\n  }\n\n  set setCookie(value: (string | SetCookieInit)[] | string | SetCookieInit | undefined | null) {\n    if (value != null) {\n      this.#setCookies = (Array.isArray(value) ? value : [value]).map((v) =>\n        typeof v === 'string' ? v : new SetCookie(v),\n      )\n    } else {\n      this.#setCookies = []\n    }\n  }\n\n  // Helpers\n\n  #getHeaderValue<T extends HeaderValue>(key: string, ctor: new (init?: any) => T): T {\n    let value = this.#map.get(key)\n\n    if (value !== undefined) {\n      if (typeof value === 'string') {\n        let obj = new ctor(value)\n        this.#map.set(key, obj) // cache the new object\n        return obj\n      } else {\n        return value as T\n      }\n    }\n\n    let obj = new ctor()\n    this.#map.set(key, obj) // cache the new object\n    return obj\n  }\n\n  #setHeaderValue(key: string, ctor: new (init?: string) => HeaderValue, value: any): void {\n    if (value != null) {\n      this.#map.set(key, typeof value === 'string' ? value : new ctor(value))\n    } else {\n      this.#map.delete(key)\n    }\n  }\n\n  #getDateValue(key: string): Date | null {\n    let value = this.#map.get(key)\n    return value === undefined ? null : new Date(value as string)\n  }\n\n  #setDateValue(key: string, value: string | DateInit | undefined | null): void {\n    if (value != null) {\n      this.#map.set(\n        key,\n        typeof value === 'string'\n          ? value\n          : (typeof value === 'number' ? new Date(value) : value).toUTCString(),\n      )\n    } else {\n      this.#map.delete(key)\n    }\n  }\n\n  #getNumberValue(key: string): number | null {\n    let value = this.#map.get(key)\n    return value === undefined ? null : parseInt(value as string, 10)\n  }\n\n  #setNumberValue(key: string, value: string | number | undefined | null): void {\n    if (value != null) {\n      this.#map.set(key, typeof value === 'string' ? value : value.toString())\n    } else {\n      this.#map.delete(key)\n    }\n  }\n\n  #getStringValue(key: string): string | null {\n    let value = this.#map.get(key)\n    return value === undefined ? null : (value as string)\n  }\n\n  #setStringValue(key: string, value: string | undefined | null): void {\n    if (value != null) {\n      this.#map.set(key, value)\n    } else {\n      this.#map.delete(key)\n    }\n  }\n}\n", "// We need this little helper for environments that do not support\n// ReadableStream.prototype[Symbol.asyncIterator] yet. See #46\nexport async function* readStream(stream: ReadableStream<Uint8Array>): AsyncIterable<Uint8Array> {\n  let reader = stream.getReader()\n\n  try {\n    while (true) {\n      let result = await reader.read()\n      if (result.done) break\n      yield result.value\n    }\n  } finally {\n    reader.releaseLock()\n  }\n}\n", "export interface SearchFunction {\n  (haystack: Uint8Array, start?: number): number\n}\n\nexport function createSearch(pattern: string): SearchFunction {\n  let needle = new TextEncoder().encode(pattern)\n\n  let search: SearchFunction\n  if ('Buffer' in globalThis && !('Bun' in globalThis || 'Deno' in globalThis)) {\n    // Use the built-in Buffer.indexOf method on Node.js for better perf.\n    search = (haystack, start = 0) => Buffer.prototype.indexOf.call(haystack, needle, start)\n  } else {\n    let needleEnd = needle.length - 1\n    let skipTable = new Uint8Array(256).fill(needle.length)\n    for (let i = 0; i < needleEnd; ++i) {\n      skipTable[needle[i]] = needleEnd - i\n    }\n\n    search = (haystack, start = 0) => {\n      let haystackLength = haystack.length\n      let i = start + needleEnd\n\n      while (i < haystackLength) {\n        for (let j = needleEnd, k = i; j >= 0 && haystack[k] === needle[j]; --j, --k) {\n          if (j === 0) return k\n        }\n\n        i += skipTable[haystack[i]]\n      }\n\n      return -1\n    }\n  }\n\n  return search\n}\n\nexport interface PartialTailSearchFunction {\n  (haystack: Uint8Array): number\n}\n\nexport function createPartialTailSearch(pattern: string): PartialTailSearchFunction {\n  let needle = new TextEncoder().encode(pattern)\n\n  let byteIndexes: Record<number, number[]> = {}\n  for (let i = 0; i < needle.length; ++i) {\n    let byte = needle[i]\n    if (byteIndexes[byte] === undefined) byteIndexes[byte] = []\n    byteIndexes[byte].push(i)\n  }\n\n  return function (haystack: Uint8Array): number {\n    let haystackEnd = haystack.length - 1\n\n    if (haystack[haystackEnd] in byteIndexes) {\n      let indexes = byteIndexes[haystack[haystackEnd]]\n\n      for (let i = indexes.length - 1; i >= 0; --i) {\n        for (let j = indexes[i], k = haystackEnd; j >= 0 && haystack[k] === needle[j]; --j, --k) {\n          if (j === 0) return k\n        }\n      }\n    }\n\n    return -1\n  }\n}\n", "import Headers from '@remix-run/headers'\n\nimport { readStream } from './read-stream.ts'\nimport type { SearchFunction, PartialTailSearchFunction } from './buffer-search.ts'\nimport { createSearch, createPartialTailSearch } from './buffer-search.ts'\n\n/**\n * The base class for errors thrown by the multipart parser.\n */\nexport class MultipartParseError extends Error {\n  constructor(message: string) {\n    super(message)\n    this.name = 'MultipartParseError'\n  }\n}\n\n/**\n * An error thrown when the maximum allowed size of a header is exceeded.\n */\nexport class MaxHeaderSizeExceededError extends MultipartParseError {\n  constructor(maxHeaderSize: number) {\n    super(`Multipart header size exceeds maximum allowed size of ${maxHeaderSize} bytes`)\n    this.name = 'MaxHeaderSizeExceededError'\n  }\n}\n\n/**\n * An error thrown when the maximum allowed size of a file is exceeded.\n */\nexport class MaxFileSizeExceededError extends MultipartParseError {\n  constructor(maxFileSize: number) {\n    super(`File size exceeds maximum allowed size of ${maxFileSize} bytes`)\n    this.name = 'MaxFileSizeExceededError'\n  }\n}\n\nexport interface ParseMultipartOptions {\n  /**\n   * The boundary string used to separate parts in the multipart message,\n   * e.g. the `boundary` parameter in the `Content-Type` header.\n   */\n  boundary: string\n  /**\n   * The maximum allowed size of a header in bytes. If an individual part's header\n   * exceeds this size, a `MaxHeaderSizeExceededError` will be thrown.\n   *\n   * Default: 8 KiB\n   */\n  maxHeaderSize?: number\n  /**\n   * The maximum allowed size of a file in bytes. If an individual part's content\n   * exceeds this size, a `MaxFileSizeExceededError` will be thrown.\n   *\n   * Default: 2 MiB\n   */\n  maxFileSize?: number\n}\n\n/**\n * Parse a `multipart/*` message from a buffer/iterable and yield each part as a `MultipartPart` object.\n *\n * Note: This is a low-level API that requires manual handling of the content and boundary. If you're\n * building a web server, consider using `parseMultipartRequest(request)` instead.\n *\n * @param message The multipart message as a `Uint8Array` or an iterable of `Uint8Array` chunks\n * @param options Options for the parser\n * @return A generator that yields `MultipartPart` objects\n */\nexport function* parseMultipart(\n  message: Uint8Array | Iterable<Uint8Array>,\n  options: ParseMultipartOptions,\n): Generator<MultipartPart, void, unknown> {\n  let parser = new MultipartParser(options.boundary, {\n    maxHeaderSize: options.maxHeaderSize,\n    maxFileSize: options.maxFileSize,\n  })\n\n  if (message instanceof Uint8Array) {\n    if (message.length === 0) {\n      return // No data to parse\n    }\n\n    yield* parser.write(message)\n  } else {\n    for (let chunk of message) {\n      yield* parser.write(chunk)\n    }\n  }\n\n  parser.finish()\n}\n\n/**\n * Parse a `multipart/*` message stream and yield each part as a `MultipartPart` object.\n *\n * Note: This is a low-level API that requires manual handling of the content and boundary. If you're\n * building a web server, consider using `parseMultipartRequest(request)` instead.\n *\n * @param stream A stream containing multipart data as a `ReadableStream<Uint8Array>`\n * @param options Options for the parser\n * @return An async generator that yields `MultipartPart` objects\n */\nexport async function* parseMultipartStream(\n  stream: ReadableStream<Uint8Array>,\n  options: ParseMultipartOptions,\n): AsyncGenerator<MultipartPart, void, unknown> {\n  let parser = new MultipartParser(options.boundary, {\n    maxHeaderSize: options.maxHeaderSize,\n    maxFileSize: options.maxFileSize,\n  })\n\n  for await (let chunk of readStream(stream)) {\n    if (chunk.length === 0) {\n      continue // No data to parse\n    }\n\n    yield* parser.write(chunk)\n  }\n\n  parser.finish()\n}\n\nexport type MultipartParserOptions = Omit<ParseMultipartOptions, 'boundary'>\n\nconst MultipartParserStateStart = 0\nconst MultipartParserStateAfterBoundary = 1\nconst MultipartParserStateHeader = 2\nconst MultipartParserStateBody = 3\nconst MultipartParserStateDone = 4\n\nconst findDoubleNewline = createSearch('\\r\\n\\r\\n')\n\nconst oneKb = 1024\nconst oneMb = 1024 * oneKb\n\n/**\n * A streaming parser for `multipart/*` HTTP messages.\n */\nexport class MultipartParser {\n  readonly boundary: string\n  readonly maxHeaderSize: number\n  readonly maxFileSize: number\n\n  #findOpeningBoundary: SearchFunction\n  #openingBoundaryLength: number\n  #findBoundary: SearchFunction\n  #findPartialTailBoundary: PartialTailSearchFunction\n  #boundaryLength: number\n\n  #state = MultipartParserStateStart\n  #buffer: Uint8Array | null = null\n  #currentPart: MultipartPart | null = null\n  #contentLength = 0\n\n  constructor(boundary: string, options?: MultipartParserOptions) {\n    this.boundary = boundary\n    this.maxHeaderSize = options?.maxHeaderSize ?? 8 * oneKb\n    this.maxFileSize = options?.maxFileSize ?? 2 * oneMb\n\n    this.#findOpeningBoundary = createSearch(`--${boundary}`)\n    this.#openingBoundaryLength = 2 + boundary.length // length of '--' + boundary\n    this.#findBoundary = createSearch(`\\r\\n--${boundary}`)\n    this.#findPartialTailBoundary = createPartialTailSearch(`\\r\\n--${boundary}`)\n    this.#boundaryLength = 4 + boundary.length // length of '\\r\\n--' + boundary\n  }\n\n  /**\n   * Write a chunk of data to the parser.\n   *\n   * @param chunk A chunk of data to write to the parser\n   * @return A generator yielding `MultipartPart` objects as they are parsed\n   */\n  *write(chunk: Uint8Array): Generator<MultipartPart, void, unknown> {\n    if (this.#state === MultipartParserStateDone) {\n      throw new MultipartParseError('Unexpected data after end of stream')\n    }\n\n    let index = 0\n    let chunkLength = chunk.length\n\n    if (this.#buffer !== null) {\n      let newChunk = new Uint8Array(this.#buffer.length + chunkLength)\n      newChunk.set(this.#buffer, 0)\n      newChunk.set(chunk, this.#buffer.length)\n      chunk = newChunk\n      chunkLength = chunk.length\n      this.#buffer = null\n    }\n\n    while (true) {\n      if (this.#state === MultipartParserStateBody) {\n        if (chunkLength - index < this.#boundaryLength) {\n          this.#buffer = chunk.subarray(index)\n          break\n        }\n\n        let boundaryIndex = this.#findBoundary(chunk, index)\n\n        if (boundaryIndex === -1) {\n          // No boundary found, but there may be a partial match at the end of the chunk.\n          let partialTailIndex = this.#findPartialTailBoundary(chunk)\n\n          if (partialTailIndex === -1) {\n            this.#append(index === 0 ? chunk : chunk.subarray(index))\n          } else {\n            this.#append(chunk.subarray(index, partialTailIndex))\n            this.#buffer = chunk.subarray(partialTailIndex)\n          }\n\n          break\n        }\n\n        this.#append(chunk.subarray(index, boundaryIndex))\n\n        yield this.#currentPart!\n\n        index = boundaryIndex + this.#boundaryLength\n\n        this.#state = MultipartParserStateAfterBoundary\n      }\n\n      if (this.#state === MultipartParserStateAfterBoundary) {\n        if (chunkLength - index < 2) {\n          this.#buffer = chunk.subarray(index)\n          break\n        }\n\n        if (chunk[index] === 45 && chunk[index + 1] === 45) {\n          this.#state = MultipartParserStateDone\n          break\n        }\n\n        index += 2 // Skip \\r\\n after boundary\n\n        this.#state = MultipartParserStateHeader\n      }\n\n      if (this.#state === MultipartParserStateHeader) {\n        if (chunkLength - index < 4) {\n          this.#buffer = chunk.subarray(index)\n          break\n        }\n\n        let headerEndIndex = findDoubleNewline(chunk, index)\n\n        if (headerEndIndex === -1) {\n          if (chunkLength - index > this.maxHeaderSize) {\n            throw new MaxHeaderSizeExceededError(this.maxHeaderSize)\n          }\n\n          this.#buffer = chunk.subarray(index)\n          break\n        }\n\n        if (headerEndIndex - index > this.maxHeaderSize) {\n          throw new MaxHeaderSizeExceededError(this.maxHeaderSize)\n        }\n\n        this.#currentPart = new MultipartPart(chunk.subarray(index, headerEndIndex), [])\n        this.#contentLength = 0\n\n        index = headerEndIndex + 4 // Skip header + \\r\\n\\r\\n\n\n        this.#state = MultipartParserStateBody\n\n        continue\n      }\n\n      if (this.#state === MultipartParserStateStart) {\n        if (chunkLength < this.#openingBoundaryLength) {\n          this.#buffer = chunk\n          break\n        }\n\n        if (this.#findOpeningBoundary(chunk) !== 0) {\n          throw new MultipartParseError('Invalid multipart stream: missing initial boundary')\n        }\n\n        index = this.#openingBoundaryLength\n\n        this.#state = MultipartParserStateAfterBoundary\n      }\n    }\n  }\n\n  #append(chunk: Uint8Array): void {\n    if (this.#contentLength + chunk.length > this.maxFileSize) {\n      throw new MaxFileSizeExceededError(this.maxFileSize)\n    }\n\n    this.#currentPart!.content.push(chunk)\n    this.#contentLength += chunk.length\n  }\n\n  /**\n   * Should be called after all data has been written to the parser.\n   *\n   * Note: This will throw if the multipart message is incomplete or\n   * wasn't properly terminated.\n   *\n   * @return void\n   */\n  finish(): void {\n    if (this.#state !== MultipartParserStateDone) {\n      throw new MultipartParseError('Multipart stream not finished')\n    }\n  }\n}\n\nconst decoder = new TextDecoder('utf-8', { fatal: true })\n\n/**\n * A part of a `multipart/*` HTTP message.\n */\nexport class MultipartPart {\n  /**\n   * The raw content of this part as an array of `Uint8Array` chunks.\n   */\n  readonly content: Uint8Array[]\n\n  #header: Uint8Array\n  #headers?: Headers\n\n  constructor(header: Uint8Array, content: Uint8Array[]) {\n    this.#header = header\n    this.content = content\n  }\n\n  /**\n   * The content of this part as an `ArrayBuffer`.\n   */\n  get arrayBuffer(): ArrayBuffer {\n    return this.bytes.buffer as ArrayBuffer\n  }\n\n  /**\n   * The content of this part as a single `Uint8Array`. In `multipart/form-data` messages, this is useful\n   * for reading the value of files that were uploaded using `<input type=\"file\">` fields.\n   */\n  get bytes(): Uint8Array {\n    let buffer = new Uint8Array(this.size)\n\n    let offset = 0\n    for (let chunk of this.content) {\n      buffer.set(chunk, offset)\n      offset += chunk.length\n    }\n\n    return buffer\n  }\n\n  /**\n   * The headers associated with this part.\n   */\n  get headers(): Headers {\n    if (!this.#headers) {\n      this.#headers = new Headers(decoder.decode(this.#header))\n    }\n\n    return this.#headers\n  }\n\n  /**\n   * True if this part originated from a file upload.\n   */\n  get isFile(): boolean {\n    return this.filename !== undefined || this.mediaType === 'application/octet-stream'\n  }\n\n  /**\n   * True if this part originated from a text input field in a form submission.\n   */\n  get isText(): boolean {\n    return !this.isFile\n  }\n\n  /**\n   * The filename of the part, if it is a file upload.\n   */\n  get filename(): string | undefined {\n    return this.headers.contentDisposition.preferredFilename\n  }\n\n  /**\n   * The media type of the part.\n   */\n  get mediaType(): string | undefined {\n    return this.headers.contentType.mediaType\n  }\n\n  /**\n   * The name of the part, usually the `name` of the field in the `<form>` that submitted the request.\n   */\n  get name(): string | undefined {\n    return this.headers.contentDisposition.name\n  }\n\n  /**\n   * The size of the content in bytes.\n   */\n  get size(): number {\n    let size = 0\n\n    for (let chunk of this.content) {\n      size += chunk.length\n    }\n\n    return size\n  }\n\n  /**\n   * The content of this part as a string. In `multipart/form-data` messages, this is useful for\n   * reading the value of parts that originated from `<input type=\"text\">` fields.\n   *\n   * Note: Do not use this for binary data, use `part.bytes` or `part.arrayBuffer` instead.\n   */\n  get text(): string {\n    return decoder.decode(this.bytes)\n  }\n}\n", "import type { MultipartParserOptions, MultipartPart } from './multipart.ts'\nimport { MultipartParseError, parseMultipartStream } from './multipart.ts'\n\n/**\n * Extracts the boundary string from a `multipart/*` content type.\n *\n * @param contentType The `Content-Type` header value from the request\n * @return The boundary string if found, or null if not present\n */\nexport function getMultipartBoundary(contentType: string): string | null {\n  let match = /boundary=(?:\"([^\"]+)\"|([^;]+))/i.exec(contentType)\n  return match ? (match[1] ?? match[2]) : null\n}\n\n/**\n * Returns true if the given request contains multipart data.\n *\n * @param request The `Request` object to check\n * @return `true` if the request is a multipart request, `false` otherwise\n */\nexport function isMultipartRequest(request: Request): boolean {\n  let contentType = request.headers.get('Content-Type')\n  return contentType != null && contentType.startsWith('multipart/')\n}\n\n/**\n * Parse a multipart [`Request`](https://developer.mozilla.org/en-US/docs/Web/API/Request) and yield each part as\n * a `MultipartPart` object. Useful in HTTP server contexts for handling incoming `multipart/*` requests.\n *\n * @param request The `Request` object containing multipart data\n * @param options Optional parser options, such as `maxHeaderSize` and `maxFileSize`\n * @return An async generator yielding `MultipartPart` objects\n */\nexport async function* parseMultipartRequest(\n  request: Request,\n  options?: MultipartParserOptions,\n): AsyncGenerator<MultipartPart, void, unknown> {\n  if (!isMultipartRequest(request)) {\n    throw new MultipartParseError('Request is not a multipart request')\n  }\n  if (!request.body) {\n    throw new MultipartParseError('Request body is empty')\n  }\n\n  let boundary = getMultipartBoundary(request.headers.get('Content-Type')!)\n  if (!boundary) {\n    throw new MultipartParseError('Invalid Content-Type header: missing boundary')\n  }\n\n  yield* parseMultipartStream(request.body, {\n    boundary,\n    maxHeaderSize: options?.maxHeaderSize,\n    maxFileSize: options?.maxFileSize,\n  })\n}\n", "import type { MultipartParserOptions, MultipartPart } from '@remix-run/multipart-parser'\nimport { isMultipartRequest, parseMultipartRequest } from '@remix-run/multipart-parser'\n\n/**\n * The base class for errors thrown by the form data parser.\n */\nexport class FormDataParseError extends Error {\n  constructor(message: string, options?: ErrorOptions) {\n    super(message, options)\n    this.name = 'FormDataParseError'\n  }\n}\n\n/**\n * An error thrown when the maximum number of files allowed in a request is exceeded.\n */\nexport class MaxFilesExceededError extends FormDataParseError {\n  constructor(maxFiles: number) {\n    super(`Maximum number of files exceeded: ${maxFiles}`)\n    this.name = 'MaxFilesExceededError'\n  }\n}\n\n/**\n * A file that was uploaded as part of a `multipart/form-data` request.\n */\nexport class FileUpload extends File {\n  /**\n   * The name of the <input> field used to upload the file.\n   */\n  readonly fieldName: string\n\n  constructor(part: MultipartPart, fieldName: string) {\n    super(part.content as BlobPart[], part.filename ?? 'file-upload', {\n      type: part.mediaType ?? 'application/octet-stream',\n    })\n\n    this.fieldName = fieldName\n  }\n}\n\n/**\n * A function used for handling file uploads.\n */\nexport interface FileUploadHandler {\n  (file: FileUpload): void | null | string | Blob | Promise<void | null | string | Blob>\n}\n\nasync function defaultFileUploadHandler(file: FileUpload): Promise<File> {\n  // By default just keep the file around in memory.\n  return file\n}\n\nexport interface ParseFormDataOptions extends MultipartParserOptions {\n  /**\n   * The maximum number of files that can be uploaded in a single request.\n   * If this limit is exceeded, a `MaxFilesExceededError` will be thrown.\n   *\n   * Default: 20\n   */\n  maxFiles?: number\n}\n\n/**\n * Parses a [`Request`](https://developer.mozilla.org/en-US/docs/Web/API/Request) body into a [`FormData`](https://developer.mozilla.org/en-US/docs/Web/API/FormData)\n * object. This is useful when accessing the data contained in a HTTP `multipart/form-data` request\n * generated by a HTML `<form>` element.\n *\n * This is a drop-in replacement for [the built-in `request.formData()` API](https://developer.mozilla.org/en-US/docs/Web/API/Request/formData)\n * with the main difference being the ability to customize the handling of file uploads. Instead of\n * keeping all files in memory, the `uploadHandler` allows you to store the file on disk or a\n * cloud storage service.\n *\n * @param request The `Request` object to parse\n * @param options Options for the parser\n * @param uploadHandler A function that handles file uploads. It receives a `File` object and may return any value that is valid in a `FormData` object\n * @return A `Promise` that resolves to a `FormData` object containing the parsed data\n */\nexport async function parseFormData(\n  request: Request,\n  uploadHandler?: FileUploadHandler,\n): Promise<FormData>\nexport async function parseFormData(\n  request: Request,\n  options?: ParseFormDataOptions,\n  uploadHandler?: FileUploadHandler,\n): Promise<FormData>\nexport async function parseFormData(\n  request: Request,\n  optionsOrUploadHandler?: ParseFormDataOptions | FileUploadHandler,\n  uploadHandler?: FileUploadHandler,\n): Promise<FormData> {\n  if (typeof optionsOrUploadHandler === 'function') {\n    uploadHandler = optionsOrUploadHandler\n    optionsOrUploadHandler = {}\n  } else if (optionsOrUploadHandler == null) {\n    optionsOrUploadHandler = {}\n  }\n  if (uploadHandler == null) {\n    uploadHandler = defaultFileUploadHandler\n  }\n\n  if (!isMultipartRequest(request)) {\n    try {\n      return await request.formData()\n    } catch (error) {\n      throw new FormDataParseError('Cannot parse form data', {\n        cause: error,\n      })\n    }\n  }\n\n  let { maxFiles = 20, ...parserOptions } = optionsOrUploadHandler\n\n  let formData = new FormData()\n  let fileCount = 0\n\n  for await (let part of parseMultipartRequest(request, parserOptions)) {\n    let fieldName = part.name\n    if (!fieldName) continue\n\n    if (part.isFile) {\n      if (++fileCount > maxFiles) {\n        throw new MaxFilesExceededError(maxFiles)\n      }\n\n      let value = await uploadHandler(new FileUpload(part, fieldName))\n      if (value != null) {\n        formData.append(fieldName, value)\n      }\n    } else {\n      formData.append(fieldName, part.text)\n    }\n  }\n\n  return formData\n}\n", "/**\n * Type-safe storage for application-specific values.\n */\nexport class AppStorage {\n  #map: Map<StorageKey<any>, StorageValue<any>> = new Map()\n\n  /**\n   * Check if a value is stored for the given key.\n   *\n   * @param key The key to check\n   * @returns `true` if a value is stored for the given key, `false` otherwise\n   */\n  has<K extends StorageKey<any>>(key: K): boolean {\n    return this.#map.has(key)\n  }\n\n  /**\n   * Get a value from storage.\n   *\n   * @param key The key to get\n   * @returns The value for the given key\n   */\n  get<K extends StorageKey<any>>(key: K): StorageValue<K> {\n    if (!this.#map.has(key)) {\n      if (key.defaultValue === undefined) {\n        throw new Error(`Missing default value in storage for key ${key}`)\n      }\n\n      return key.defaultValue\n    }\n\n    return this.#map.get(key) as StorageValue<K>\n  }\n\n  /**\n   * Set a value in storage.\n   *\n   * @param key The key to set\n   * @param value The value to set\n   */\n  set<K extends StorageKey<any>>(key: K, value: StorageValue<K>): void {\n    this.#map.set(key, value)\n  }\n}\n\n/**\n * Create a storage key with an optional default value.\n *\n * @param defaultValue The default value for the storage key\n * @returns The new storage key\n */\nexport function createStorageKey<T>(defaultValue?: T): StorageKey<T> {\n  return { defaultValue }\n}\n\nexport interface StorageKey<T> {\n  defaultValue?: T\n}\n\nexport type StorageValue<TKey> = TKey extends StorageKey<infer T> ? T : never\n", "type Range = [number, number] // [start (inclusive), end (exclusive)]\n\nexport interface SplitResult {\n  protocol: Range | undefined\n  hostname: Range | undefined\n  port: Range | undefined\n  pathname: Range | undefined\n  search: Range | undefined\n}\n\n/**\n * Split a route pattern into protocol, hostname, port, pathname, and search\n * ranges. Ranges are [start (inclusive), end (exclusive)].\n */\nexport function split<T extends string>(source: T): SplitResult {\n  let protocol: Range | undefined\n  let hostname: Range | undefined\n  let port: Range | undefined\n  let pathname: Range | undefined\n  let search: Range | undefined\n\n  // search\n  let searchStart = source.indexOf('?')\n  if (searchStart !== -1) {\n    search = [searchStart + 1, source.length]\n    source = source.slice(0, searchStart) as T\n  }\n\n  let index = 0\n  let solidusIndex = source.indexOf('://')\n  if (solidusIndex !== -1) {\n    // protocol\n    if (solidusIndex !== 0) {\n      protocol = [0, solidusIndex]\n    }\n    index = solidusIndex + 3\n\n    // hostname + port\n    let hostEndIndex = source.indexOf('/', index)\n    if (hostEndIndex === -1) hostEndIndex = source.length\n\n    // detect port (numeric) at end of host segment\n    let colonIndex = source.lastIndexOf(':', hostEndIndex - 1)\n    if (colonIndex !== -1 && colonIndex >= index) {\n      // Ensure everything after the colon is digits\n      let isPort = true\n      for (let i = colonIndex + 1; i < hostEndIndex; i++) {\n        let char = source.charCodeAt(i)\n        if (char < 48 /* '0' */ || char > 57 /* '9' */) {\n          isPort = false\n          break\n        }\n      }\n\n      if (isPort && colonIndex + 1 < hostEndIndex) {\n        // hostname up to colon, port after colon\n        hostname = [index, colonIndex]\n        port = [colonIndex + 1, hostEndIndex]\n      } else {\n        hostname = [index, hostEndIndex]\n      }\n    } else {\n      hostname = [index, hostEndIndex]\n    }\n\n    index = hostEndIndex === source.length ? hostEndIndex : hostEndIndex + 1\n  }\n\n  // pathname\n  if (index !== source.length) {\n    if (source.charAt(index) === '/') {\n      index += 1\n    }\n\n    pathname = [index, source.length]\n  }\n\n  return { protocol, hostname, port, pathname, search }\n}\n\nexport interface SplitPattern {\n  protocol: string | undefined\n  hostname: string | undefined\n  port: string | undefined\n  pathname: string | undefined\n  search: string | undefined\n}\n\n// prettier-ignore\nexport type Split<T extends string> =\n  _Split<T> extends infer S extends Partial<SplitPattern> ? {\n    protocol: S['protocol'] extends string ? S['protocol'] : undefined\n    hostname: S['hostname'] extends string ? S['hostname'] : undefined\n    port: S['port'] extends string ? S['port'] : undefined\n    pathname: S['pathname'] extends string ? S['pathname'] : undefined\n    search: S['search'] extends string ? S['search'] : undefined\n  } :\n  never\n\n// prettier-ignore\ntype _Split<T extends string> =\n  T extends '' ? {} :\n  T extends `${infer L}?${infer R}` ? _Split<L> & { search: R } :\n  T extends `${infer Protocol}://${infer R}` ?\n    Protocol extends '' ? (\n      R extends `${infer Host}/${infer Pathname}` ? SplitHost<Host> & { pathname: Pathname } :\n      SplitHost<R>\n    ) :\n    Protocol extends `${string}/${string}` ? { pathname: T } :\n    R extends `${infer Host}/${infer Pathname}` ? SplitHost<Host> & { protocol: Protocol; pathname: Pathname } :\n    SplitHost<R> & { protocol: Protocol } :\n  T extends `/${infer Pathname}` ? { pathname: Pathname } :\n  { pathname: T }\n\n// prettier-ignore\ntype SplitHost<T extends string> =\n  T extends `${infer L}:${infer R}` ?\n    IsDigits<R> extends true ? { hostname: L; port: R} :\n    SplitHost<R> extends { hostname: infer H extends string; port: infer P extends string } ? { hostname: `${L}:${H}`; port: P } :\n    { hostname: T } :\n  { hostname: T }\n\ntype _0_9 = '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9'\n\n// prettier-ignore\ntype IsDigits<S extends string> =\n  S extends `${_0_9}${infer T}` ?\n    T extends '' ? true :\n    IsDigits<T> :\n  false\n", "export type SearchConstraints = Map<\n  string,\n  { requiredValues?: Set<string>; requireAssignment: boolean; allowBare: boolean }\n>\n\nexport function parseSearchConstraints(search: string): SearchConstraints {\n  let constraints: SearchConstraints = new Map()\n\n  for (let part of search.split('&')) {\n    if (part === '') continue\n    let eqIndex = part.indexOf('=')\n    if (eqIndex === -1) {\n      // Presence-only (no '=')\n      let name = decodeSearchComponent(part)\n      let existing = constraints.get(name)\n      if (!existing) {\n        constraints.set(name, { requireAssignment: false, allowBare: true })\n      }\n      continue\n    }\n\n    let name = decodeSearchComponent(part.slice(0, eqIndex))\n    let valuePart = part.slice(eqIndex + 1)\n    let existing = constraints.get(name)\n    if (!existing) {\n      existing = { requireAssignment: true, allowBare: false }\n      constraints.set(name, existing)\n    } else {\n      existing.requireAssignment = true\n      existing.allowBare = false\n    }\n\n    if (valuePart.length > 0) {\n      let decodedValue = decodeSearchComponent(valuePart)\n      if (!existing.requiredValues) existing.requiredValues = new Set<string>()\n      existing.requiredValues.add(decodedValue)\n    }\n  }\n\n  return constraints\n}\n\nexport function parseSearch(search: string): {\n  namesWithoutAssignment: Set<string>\n  namesWithAssignment: Set<string>\n  valuesByKey: Map<string, Set<string>>\n} {\n  if (search.startsWith('?')) search = search.slice(1)\n\n  let namesWithoutAssignment = new Set<string>(),\n    namesWithAssignment = new Set<string>(),\n    valuesByKey = new Map<string, Set<string>>()\n\n  if (search.length > 0) {\n    for (let part of search.split('&')) {\n      if (part === '') continue\n      let eqIndex = part.indexOf('=')\n      if (eqIndex === -1) {\n        let name = decodeSearchComponent(part)\n        namesWithoutAssignment.add(name)\n        continue\n      }\n\n      let name = decodeSearchComponent(part.slice(0, eqIndex))\n      let valuePart = part.slice(eqIndex + 1)\n      namesWithAssignment.add(name)\n      let value = decodeSearchComponent(valuePart)\n      let set = valuesByKey.get(name) ?? new Set<string>()\n      if (!valuesByKey.has(name)) valuesByKey.set(name, set)\n      set.add(value)\n    }\n  }\n\n  return { namesWithoutAssignment, namesWithAssignment, valuesByKey }\n}\n\nfunction decodeSearchComponent(text: string): string {\n  try {\n    return decodeURIComponent(text.replace(/\\+/g, ' '))\n  } catch {\n    return text\n  }\n}\n", "import { split } from './split.ts'\nimport type { SplitPattern, Split } from './split.ts'\nimport { parseSearchConstraints } from './search-constraints.ts'\nimport type { SearchConstraints } from './search-constraints.ts'\n\nexport class ParseError extends Error {\n  source: string\n  position: number\n  partName: string\n\n  constructor(description: string, partName: string, source: string, position: number) {\n    super(`${description} in ${partName}`)\n    this.name = 'ParseError'\n    this.source = source\n    this.position = position\n    this.partName = partName\n  }\n}\n\nexport interface ParseResult {\n  protocol: Array<Token> | undefined\n  hostname: Array<Token> | undefined\n  port: string | undefined\n  pathname: Array<Token> | undefined\n  search: string | undefined\n  searchConstraints: SearchConstraints | undefined\n}\n\nexport function parse<T extends string>(source: T): ParseResult {\n  let protocol: Token[] | undefined\n  let hostname: Token[] | undefined\n  let port: string | undefined\n  let pathname: Token[] | undefined\n  let search: string | undefined\n  let searchConstraints: SearchConstraints | undefined\n\n  let ranges = split(source)\n\n  if (ranges.protocol) {\n    protocol = parsePart('protocol', '', source, ...ranges.protocol)\n  }\n  if (ranges.hostname) {\n    hostname = parsePart('hostname', '.', source, ...ranges.hostname)\n  }\n  if (ranges.port) {\n    port = source.slice(...ranges.port)\n  }\n  if (ranges.pathname) {\n    pathname = parsePart('pathname', '/', source, ...ranges.pathname)\n  }\n  if (ranges.search) {\n    search = source.slice(...ranges.search)\n    searchConstraints = parseSearchConstraints(search)\n  }\n\n  return { protocol, hostname, port, pathname, search, searchConstraints }\n}\n\nconst identifierMatcher = /^[a-zA-Z_$][a-zA-Z_$0-9]*/\n\nfunction parsePart(partName: string, sep: string, source: string, start: number, end: number) {\n  let tokens: Token[] = []\n  let currentTokens = tokens\n  // Use a simple stack of token arrays: the top is where new tokens are appended.\n  // The root of the stack is the `part` array. Each '(' pushes a new array; ')'\n  // pops and wraps it in an optional token which is appended to the new top.\n  let tokensStack: Array<Token[]> = [tokens]\n  let openIndexes: Array<number> = []\n\n  let appendText = (text: string) => {\n    let lastToken = currentTokens.at(-1)\n    if (lastToken?.type === 'text') {\n      lastToken.value += text\n    } else {\n      currentTokens.push({ type: 'text', value: text })\n    }\n  }\n\n  let i = start\n  while (i < end) {\n    let char = source[i]\n\n    // separator\n    if (char === sep) {\n      currentTokens.push({ type: 'separator' })\n      i += 1\n      continue\n    }\n\n    // variable\n    if (char === ':') {\n      i += 1\n      let remaining = source.slice(i, end)\n      let name = identifierMatcher.exec(remaining)?.[0]\n      if (!name) throw new ParseError('missing variable name', partName, source, i)\n      currentTokens.push({ type: 'variable', name })\n      i += name.length\n      continue\n    }\n\n    // wildcard\n    if (char === '*') {\n      i += 1\n      let remaining = source.slice(i, end)\n      let name = identifierMatcher.exec(remaining)?.[0]\n      if (name) {\n        currentTokens.push({ type: 'wildcard', name })\n        i += name.length\n      } else {\n        currentTokens.push({ type: 'wildcard' })\n      }\n      continue\n    }\n\n    // optional\n    if (char === '(') {\n      tokensStack.push((currentTokens = []))\n      openIndexes.push(i)\n      i += 1\n      continue\n    }\n    if (char === ')') {\n      if (tokensStack.length === 1) throw new ParseError('unmatched )', partName, source, i)\n      let tokens = tokensStack.pop()!\n      currentTokens = tokensStack[tokensStack.length - 1]\n      currentTokens.push({ type: 'optional', tokens })\n      openIndexes.pop()\n      i += 1\n      continue\n    }\n\n    // text\n    if (char === '\\\\') {\n      let next = source.at(i + 1)\n      if (!next || i + 1 >= end) throw new ParseError('dangling escape', partName, source, i)\n      appendText(next)\n      i += 2\n      continue\n    }\n\n    appendText(char)\n    i += 1\n  }\n\n  if (openIndexes.length > 0) {\n    // Report the position of the earliest unmatched '('\n    throw new ParseError('unmatched (', partName, source, openIndexes[0])\n  }\n\n  return tokens\n}\n\nexport interface ParsedPattern {\n  protocol: Token[] | undefined\n  hostname: Token[] | undefined\n  port: string | undefined\n  pathname: Token[] | undefined\n  search: string | undefined\n}\n\n// prettier-ignore\nexport type Parse<T extends string> =\n  [T] extends [string] ?\n    Split<T> extends infer S extends SplitPattern ?\n      {\n        protocol: S['protocol'] extends string ? ParsePart<S['protocol']> : undefined\n        hostname: S['hostname'] extends string ? ParsePart<S['hostname'], '.'> : undefined\n        port: S['port'] extends string ? S['port'] : undefined\n        pathname: S['pathname'] extends string ? ParsePart<S['pathname'], '/'> : undefined\n        search: S['search'] extends string ? S['search'] : undefined\n      } :\n      never :\n    never\n\nexport type Variable = { type: 'variable'; name: string }\nexport type Wildcard = { type: 'wildcard'; name?: string }\nexport type Text = { type: 'text'; value: string }\nexport type Separator = { type: 'separator' }\nexport type Optional = { type: 'optional'; tokens: Token[] }\n\nexport type Token = Variable | Wildcard | Text | Separator | Optional\n\ntype ParsePartState = {\n  tokens: Token[]\n  optionals: Array<Token[]>\n  rest: string\n}\n\ntype ParsePart<T extends string, Sep extends string = ''> = _ParsePart<\n  {\n    tokens: []\n    optionals: []\n    rest: T\n  },\n  Sep\n>\n\n// prettier-ignore\ntype _ParsePart<S extends ParsePartState, Sep extends string = ''> =\n  S extends { rest: `${infer Head}${infer Tail}` } ?\n    Head extends Sep ? _ParsePart<AppendToken<S, { type: 'separator' }, Tail>, Sep> :\n    Head extends ':' ?\n      IdentifierParse<Tail> extends { identifier: infer name extends string, rest: infer rest extends string } ?\n        (name extends '' ? never : _ParsePart<AppendToken<S, { type: 'variable', name: name }, rest>, Sep>) :\n      never : // this should never happen\n    Head extends '*' ?\n      IdentifierParse<Tail> extends { identifier: infer name extends string, rest: infer rest extends string } ?\n        _ParsePart<AppendToken<S, (name extends '' ? { type: 'wildcard' } : { type: 'wildcard', name: name }), rest>, Sep> :\n      never : // this should never happen\n    Head extends '(' ? _ParsePart<PushOptional<S, Tail>, Sep> :\n    Head extends ')' ?\n      PopOptional<S, Tail> extends infer next extends ParsePartState ? _ParsePart<next, Sep> :\n      never : // unmatched `)` handled in PopOptional\n    Head extends '\\\\' ?\n      Tail extends `${infer L}${infer R}` ? _ParsePart<AppendText<S, L, R>, Sep> :\n      never : // dangling escape\n    _ParsePart<AppendText<S, Head, Tail>, Sep> :\n  S['optionals'] extends [] ? S['tokens'] :\n  never // unmatched `(`\n\n// prettier-ignore\ntype AppendToken<S extends ParsePartState, token extends Token, rest extends string> =\n  S['optionals'] extends [...infer O extends Array<Token[]>, infer Top extends Token[]] ?\n    {\n      tokens: S['tokens']\n      optionals: [...O, [...Top, token]]\n      rest: rest\n    } :\n    {\n      tokens: [...S['tokens'], token]\n      optionals: S['optionals']\n      rest: rest;\n    }\n\n// prettier-ignore\ntype AppendText<S extends ParsePartState, text extends string, rest extends string> =\n  S['optionals'] extends [...infer O extends Array<Token[]>, infer Top extends Token[]] ?\n    (\n      Top extends [...infer Tokens extends Array<Token>, { type: 'text', value: infer value extends string }] ?\n        { tokens: S['tokens']; optionals: [...O, [...Tokens, { type: 'text', value: `${value}${text}` }]]; rest: rest } :\n        { tokens: S['tokens']; optionals: [...O, [...Top, { type: 'text', value: text }]]; rest: rest }\n    ) :\n    (\n      S['tokens'] extends [...infer Tokens extends Array<Token>, { type: 'text', value: infer value extends string }] ?\n        { tokens: [...Tokens, { type: 'text', value: `${value}${text}` }]; optionals: S['optionals']; rest: rest } :\n        { tokens: [...S['tokens'], { type: 'text', value: text }]; optionals: S['optionals']; rest: rest }\n    )\n\n// Optional stack helpers ---------------------------------------------------------------------------\n\ntype PushOptional<S extends ParsePartState, rest extends string> = {\n  tokens: S['tokens']\n  optionals: [...S['optionals'], []]\n  rest: rest\n}\n\n// If stack is empty -> unmatched ')', return never\n// Else pop and wrap tokens into an Optional token; append to parent or part\ntype PopOptional<S extends ParsePartState, R extends string> = S['optionals'] extends [\n  ...infer O extends Array<Token[]>,\n  infer Top extends Array<Token>,\n]\n  ? O extends [...infer OO extends Array<Token[]>, infer Parent extends Token[]]\n    ? {\n        tokens: S['tokens']\n        optionals: [...OO, [...Parent, { type: 'optional'; tokens: Top }]]\n        rest: R\n      }\n    : { tokens: [...S['tokens'], { type: 'optional'; tokens: Top }]; optionals: []; rest: R }\n  : never\n\n// Identifier --------------------------------------------------------------------------------------\n\n// prettier-ignore\ntype _a_z = 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z'\ntype _A_Z = Uppercase<_a_z>\ntype _0_9 = '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9'\n\ntype IdentifierHead = _a_z | _A_Z | '_' | '$'\ntype IdentifierTail = IdentifierHead | _0_9\n\ntype IdentifierParse<T extends string> = _IdentifierParse<{ identifier: ''; rest: T }>\n\n// prettier-ignore\ntype _IdentifierParse<S extends { identifier: string, rest: string }> =\n  S extends { identifier: '', rest: `${infer Head extends IdentifierHead}${infer Tail}` } ?\n    _IdentifierParse<{ identifier: Head, rest: Tail }> :\n    S extends { identifier: string, rest: `${infer Head extends IdentifierTail}${infer Tail}`} ?\n      _IdentifierParse<{ identifier: `${S['identifier']}${Head}`, rest: Tail }> :\n      S\n", "import type { RequiredParams, OptionalParams } from './params.ts'\nimport { parse } from './parse.ts'\nimport type { ParseResult } from './parse.ts'\nimport type { Token } from './parse.ts'\nimport type { RoutePattern } from './route-pattern.ts'\nimport type { Variant } from './variant.ts'\n\nexport class MissingParamError extends Error {\n  readonly paramName: string\n\n  constructor(paramName: string) {\n    super(`Missing required parameter: ${paramName}`)\n    this.name = 'MissingParamError'\n    this.paramName = paramName\n  }\n}\n\nexport function createHrefBuilder<T extends string | RoutePattern = string>(): HrefBuilder<T> {\n  return (pattern: string | RoutePattern, ...args: any) =>\n    formatHref(parse(typeof pattern === 'string' ? pattern : pattern.source), ...args)\n}\n\nexport function formatHref(\n  parsed: ParseResult,\n  params?: Record<string, any>,\n  searchParams?: Record<string, any>,\n): string {\n  params = params ?? {}\n\n  let href = ''\n\n  if (parsed.hostname != null) {\n    // Default protocol is https because it's free these days so there's no\n    // excuse not to use it.\n    let protocol = parsed.protocol != null ? resolveTokens(parsed.protocol, '', params) : 'https'\n    let hostname = resolveTokens(parsed.hostname, '.', params)\n    let port = parsed.port != null ? `:${parsed.port}` : ''\n    href += `${protocol}://${hostname}${port}`\n  }\n\n  if (parsed.pathname != null) {\n    let pathname = resolveTokens(parsed.pathname, '/', params)\n    href += pathname.startsWith('/') ? pathname : `/${pathname}`\n  } else {\n    href += '/'\n  }\n\n  if (searchParams) {\n    href += `?${new URLSearchParams(searchParams)}`\n  } else if (parsed.search) {\n    href += `?${parsed.search}`\n  }\n\n  return href\n}\n\nfunction resolveTokens(tokens: Token[], sep: string, params: Record<string, any>): string {\n  let str = ''\n\n  for (let token of tokens) {\n    if (token.type === 'variable' || token.type === 'wildcard') {\n      let name = token.name ?? '*'\n      if (params[name] == null) throw new MissingParamError(name)\n      str += String(params[name])\n    } else if (token.type === 'text') {\n      str += token.value\n    } else if (token.type === 'separator') {\n      str += sep\n    } else if (token.type === 'optional') {\n      try {\n        str += resolveTokens(token.tokens, sep, params)\n      } catch (error) {\n        if (!(error instanceof MissingParamError)) {\n          throw error\n        }\n\n        // Missing required parameter, ok to skip since it's optional\n      }\n    }\n  }\n\n  return str\n}\n\nexport interface HrefBuilder<T extends string | RoutePattern = string> {\n  <P extends string extends T ? string : SourceOf<T> | Variant<SourceOf<T>>>(\n    pattern: P | RoutePattern<P>,\n    ...args: HrefBuilderArgs<P>\n  ): string\n}\n\n// prettier-ignore\ntype SourceOf<T> =\n  T extends string ? T :\n  T extends RoutePattern<infer S extends string> ? S :\n  never\n\n// prettier-ignore\nexport type HrefBuilderArgs<T extends string> =\n  [RequiredParams<T>] extends [never] ?\n    [] | [null | undefined | Record<string, any>] | [null | undefined | Record<string, any>, HrefSearchParams] :\n    [HrefParams<T>, HrefSearchParams] | [HrefParams<T>]\n\n// prettier-ignore\ntype HrefParams<T extends string> =\n  Record<RequiredParams<T>, ParamValue> &\n  Partial<Record<OptionalParams<T>, ParamValue | null | undefined>>\n\ntype HrefSearchParams =\n  | NonNullable<ConstructorParameters<typeof URLSearchParams>[0]>\n  | Record<string, ParamValue>\n\ntype ParamValue = string | number | bigint | boolean\n", "import type { Token, ParseResult, ParsedPattern } from './parse.ts'\nimport type { SearchConstraints } from './search-constraints.ts'\n\nexport function stringify(parsed: Partial<ParseResult>): string {\n  let str = ''\n\n  if (parsed.hostname != null) {\n    let protocol = parsed.protocol != null ? stringifyTokens(parsed.protocol) : ''\n    let hostname = parsed.hostname != null ? stringifyTokens(parsed.hostname, '.') : ''\n    let port = parsed.port != null ? `:${parsed.port}` : ''\n    str += `${protocol}://${hostname}${port}`\n  }\n\n  if (parsed.pathname != null) {\n    let pathname = stringifyTokens(parsed.pathname, '/')\n    str += startsWithSeparator(parsed.pathname) ? pathname : `/${pathname}`\n  } else {\n    str += '/'\n  }\n\n  if (parsed.search) {\n    str += `?${parsed.search}`\n  } else if (parsed.searchConstraints != null) {\n    let search = stringifySearchConstraints(parsed.searchConstraints)\n    if (search !== '') {\n      str += `?${search}`\n    }\n  }\n\n  return str\n}\n\nexport function startsWithSeparator(tokens: Token[]): boolean {\n  if (tokens.length === 0) return false\n\n  let firstToken = tokens[0]\n  if (firstToken.type === 'separator') return true\n\n  // Check if it starts with an optional that contains a separator\n  if (firstToken.type === 'optional' && firstToken.tokens && firstToken.tokens.length > 0) {\n    return startsWithSeparator(firstToken.tokens)\n  }\n\n  return false\n}\n\nexport function stringifyTokens(tokens: Token[], sep = ''): string {\n  let str = ''\n\n  for (let i = 0; i < tokens.length; i++) {\n    let token = tokens[i]\n    if (token.type === 'variable') {\n      str += `:${token.name}`\n    } else if (token.type === 'wildcard') {\n      str += `*${token.name ?? ''}`\n    } else if (token.type === 'text') {\n      str += token.value\n    } else if (token.type === 'separator') {\n      str += sep\n    } else if (token.type === 'optional') {\n      str += `(${stringifyTokens(token.tokens, sep)})`\n    }\n  }\n\n  return str\n}\n\nexport function stringifySearchConstraints(search: SearchConstraints): string {\n  let parts: string[] = []\n\n  for (let [key, value] of search.entries()) {\n    if (value.allowBare && !value.requireAssignment) {\n      // Parameter can appear without assignment (e.g., just \"debug\")\n      parts.push(key)\n    } else if (value.requiredValues && value.requiredValues.size > 0) {\n      // Parameter has specific required values - create separate entries for each value\n      for (let requiredValue of value.requiredValues) {\n        parts.push(`${key}=${requiredValue}`)\n      }\n    } else if (value.requireAssignment) {\n      // Parameter requires assignment but no specific values\n      parts.push(`${key}=`)\n    }\n  }\n\n  return parts.join('&')\n}\n\n// prettier-ignore\nexport type Stringify<T extends ParsedPattern> =\n  T['hostname'] extends Token[] ?\n    `${StringifyTokens<T['protocol'], ''>}://${StringifyTokens<T['hostname'], '.'>}${StringifyPort<T['port']>}${StringifyPathname<T['pathname']>}${StringifySearch<T['search']>}` :\n    `${StringifyPathname<T['pathname']>}${StringifySearch<T['search']>}`\n\n// prettier-ignore\ntype StringifyTokens<T extends Token[] | undefined, Sep extends string> =\n  T extends undefined ? '' :\n  T extends [] ? '' :\n  T extends [infer Head extends Token, ...infer Tail extends Token[]] ?\n    `${StringifyToken<Head, Sep>}${StringifyTokens<Tail, Sep>}` :\n    never\n\n// prettier-ignore\ntype StringifyToken<T extends Token, Sep extends string> =\n  T extends { type: 'text', value: infer V extends string } ? V :\n  T extends { type: 'variable', name: infer N extends string } ? `:${N}` :\n  T extends { type: 'wildcard', name: infer N extends string } ? `*${N}` :\n  T extends { type: 'wildcard' } ? '*' :\n  T extends { type: 'separator' } ? Sep :\n  T extends { type: 'optional', tokens: infer Tokens extends Token[] } ? `(${StringifyTokens<Tokens, Sep>})` :\n  never\n\n// prettier-ignore\ntype StringifyPathname<T extends Token[] | undefined> =\n  T extends undefined ? '/' :\n  T extends [] ? '/' :\n  T extends Token[] ?\n    StartsWithSeparator<T> extends true ?\n      `${StringifyTokens<T, '/'>}` :\n      `/${StringifyTokens<T, '/'>}` :\n    never\n\ntype StringifyPort<T extends string | undefined> = T extends string ? `:${T}` : ''\n\ntype StringifySearch<T extends string | undefined> = T extends string ? `?${T}` : ''\n\n// prettier-ignore\nexport type StartsWithSeparator<T extends Token[]> =\n  T extends [] ? false :\n  T extends [{ type: 'separator' }, ...Token[]] ? true :\n  T extends [{ type: 'optional', tokens: infer Tokens extends Token[] }, ...Token[]] ?\n    StartsWithSeparator<Tokens> :\n    false\n", "import type { Parse, ParsedPattern, ParseResult, Separator, Token } from './parse.ts'\nimport type { SearchConstraints } from './search-constraints.ts'\nimport { stringify, startsWithSeparator } from './stringify.ts'\nimport type { Stringify, StartsWithSeparator } from './stringify.ts'\n\nexport function join(a: ParseResult, b: ParseResult): string {\n  let { protocol, hostname, port } = b.hostname != null ? b : a\n  let pathname = joinPathnames(a.pathname, b.pathname)\n  let searchConstraints = joinSearchConstraints(a.searchConstraints, b.searchConstraints)\n\n  return stringify({\n    protocol,\n    hostname,\n    port,\n    pathname,\n    searchConstraints,\n  })\n}\n\nfunction joinPathnames(a: Token[] | undefined, b: Token[] | undefined): Token[] | undefined {\n  if (b == null || b.length === 0) return a\n  if (a == null || a.length === 0) return b\n\n  let tokens = [...a]\n\n  // Remove trailing separator from base if present\n  if (tokens.length > 0 && tokens[tokens.length - 1].type === 'separator') {\n    tokens.pop()\n  }\n\n  // Check if input starts with a separator (including inside optionals)\n  let inputStartsWithSeparator = startsWithSeparator(b)\n\n  // If input is exactly a single separator, there is nothing to append.\n  // This avoids creating a trailing slash like \"/hello/\" when joining with base '/'.\n  if (b.length === 1 && b[0].type === 'separator') {\n    return tokens\n  }\n\n  // Only add separator between base and input if input doesn't start with one\n  if (!inputStartsWithSeparator) {\n    tokens.push({ type: 'separator' })\n  }\n\n  // Add input pathname\n  tokens.push(...b)\n\n  return tokens\n}\n\nfunction joinSearchConstraints(\n  baseSearch: SearchConstraints | undefined,\n  inputSearch: SearchConstraints | undefined,\n): SearchConstraints | undefined {\n  if (inputSearch == null) return baseSearch\n  if (baseSearch == null) return inputSearch\n\n  // Merge the two search constraint maps\n  let merged = new Map(baseSearch)\n\n  for (let [key, inputConstraint] of inputSearch.entries()) {\n    let baseConstraint = merged.get(key)\n    if (baseConstraint == null) {\n      merged.set(key, inputConstraint)\n    } else {\n      // Merge constraints for the same key\n      let mergedConstraint = {\n        requireAssignment: baseConstraint.requireAssignment || inputConstraint.requireAssignment,\n        allowBare: baseConstraint.allowBare && inputConstraint.allowBare,\n        requiredValues: undefined as Set<string> | undefined,\n      }\n\n      // Merge required values\n      if (baseConstraint.requiredValues || inputConstraint.requiredValues) {\n        mergedConstraint.requiredValues = new Set([\n          ...(baseConstraint.requiredValues || []),\n          ...(inputConstraint.requiredValues || []),\n        ])\n      }\n\n      merged.set(key, mergedConstraint)\n    }\n  }\n\n  return merged\n}\n\nexport type Join<A extends string, B extends string> = _Join<Parse<A>, Parse<B>>\n\ntype _Join<A extends ParsedPattern, B extends ParsedPattern> = Stringify<{\n  protocol: JoinOriginField<A, B, 'protocol'>\n  hostname: JoinOriginField<A, B, 'hostname'>\n  port: JoinOriginField<A, B, 'port'>\n  pathname: JoinPathnames<A['pathname'], B['pathname']>\n  search: JoinSearch<A['search'], B['search']>\n}>\n\n// prettier-ignore\ntype JoinOriginField<\n  A extends ParsedPattern,\n  B extends ParsedPattern,\n  Field extends 'protocol' | 'hostname' | 'port'\n> = B['hostname'] extends Token[] ? B[Field] : A[Field]\n\n// prettier-ignore\ntype JoinPathnames<A extends Token[] | undefined, B extends Token[] | undefined> =\n  B extends undefined ? A :\n  B extends [] ? A :\n  A extends undefined ? B :\n  A extends [] ? B :\n  A extends Token[] ?\n    B extends Token[] ? JoinPathnameTokens<RemoveTrailingSeparator<A>, B> :\n    never :\n  never\n\n// prettier-ignore\ntype RemoveTrailingSeparator<T extends Token[]> =\n  T extends [...infer Rest extends Token[], Separator] ? Rest : T\n\n// prettier-ignore\ntype JoinPathnameTokens<\n  A extends Token[],\n  B extends Token[]\n> = B extends [Separator] ?\n    A :\n    StartsWithSeparator<B> extends true ?\n      [...A, ...B] :\n      [...A, Separator, ...B]\n\n// prettier-ignore\ntype JoinSearch<\n  A extends string | undefined,\n  B extends string | undefined\n> = B extends undefined ? A :\n    A extends undefined ? B :\n    `${A}&${B}`\n", "import { formatHref } from './href.ts'\nimport type { HrefBuilderArgs } from './href.ts'\nimport { join } from './join.ts'\nimport type { Join } from './join.ts'\nimport type { Params } from './params.ts'\nimport { parse } from './parse.ts'\nimport type { Token, ParseResult } from './parse.ts'\nimport { parseSearch } from './search-constraints.ts'\nimport type { SearchConstraints } from './search-constraints.ts'\n\nexport interface RoutePatternOptions {\n  /**\n   * Whether to ignore case when matching URL pathnames.\n   */\n  ignoreCase?: boolean\n}\n\n/**\n * A pattern for matching URLs.\n */\nexport class RoutePattern<T extends string = string> {\n  /**\n   * The source string that was used to create this pattern.\n   */\n  readonly source: T\n  /**\n   * Whether to ignore case when matching URL pathnames.\n   */\n  readonly ignoreCase: boolean\n\n  #parsed: ParseResult\n  #compiled: CompileResult | undefined\n\n  constructor(source: T | RoutePattern<T>, options?: RoutePatternOptions) {\n    this.source = typeof source === 'string' ? source : source.source\n    this.ignoreCase = options?.ignoreCase === true\n    this.#parsed = parse(this.source)\n  }\n\n  /**\n   * Generate a href (URL) for this pattern.\n   *\n   * @param params The parameters to use in the href.\n   * @param searchParams The search parameters to use in the href.\n   * @returns The href\n   */\n  href(...args: HrefBuilderArgs<T>): string {\n    return formatHref(this.#parsed, ...(args as any))\n  }\n\n  /**\n   * Join this pattern with another pattern. This is useful when building a pattern\n   * relative to a base pattern.\n   *\n   * Note: The returned pattern will use the same options as this pattern.\n   *\n   * @param input The pattern to join with\n   * @returns The joined pattern\n   */\n  join<P extends string>(input: P | RoutePattern<P>): RoutePattern<Join<T, P>> {\n    let parsedInput = parse(typeof input === 'string' ? input : input.source)\n    return new RoutePattern(join(this.#parsed, parsedInput) as Join<T, P>, {\n      ignoreCase: this.ignoreCase,\n    })\n  }\n\n  /**\n   * Match a URL against this pattern.\n   *\n   * @param url The URL to match\n   * @returns The parameters if the URL matches this pattern, `null` otherwise\n   */\n  match(url: URL | string): RouteMatch<T> | null {\n    if (typeof url === 'string') url = new URL(url)\n\n    let { matchOrigin, matcher, paramNames } = this.#compile()\n\n    let pathname = this.ignoreCase ? url.pathname.toLowerCase() : url.pathname\n    let match = matcher.exec(matchOrigin ? `${url.origin}${pathname}` : pathname)\n    if (match === null) return null\n\n    // Map positional capture groups to parameter names in source order\n    let params = {} as any\n    for (let i = 0; i < paramNames.length; i++) {\n      let paramName = paramNames[i]\n      params[paramName] = match[i + 1]\n    }\n\n    if (\n      this.#parsed.searchConstraints != null &&\n      !matchSearch(url.search, this.#parsed.searchConstraints)\n    ) {\n      return null\n    }\n\n    return { url, params }\n  }\n\n  #compile(): CompileResult {\n    if (this.#compiled) return this.#compiled\n    this.#compiled = compilePattern(this.#parsed, this.ignoreCase)\n    return this.#compiled\n  }\n\n  /**\n   * Test if a URL matches this pattern.\n   *\n   * @param url The URL to test\n   * @returns `true` if the URL matches this pattern, `false` otherwise\n   */\n  test(url: URL | string): boolean {\n    return this.match(url) !== null\n  }\n\n  toString() {\n    return this.source\n  }\n}\n\nexport interface RouteMatch<T extends string> {\n  /**\n   * The parameters that were extracted from the URL protocol, hostname, and/or pathname.\n   */\n  readonly params: Params<T>\n  /**\n   * The URL that was matched.\n   */\n  readonly url: URL\n}\n\ninterface CompileResult {\n  matchOrigin: boolean\n  matcher: RegExp\n  paramNames: string[]\n}\n\nfunction compilePattern(parsed: ParseResult, ignoreCase: boolean): CompileResult {\n  let { protocol, hostname, port, pathname } = parsed\n\n  let matchOrigin = hostname !== undefined\n  let matcher: RegExp\n  let paramNames: string[] = []\n\n  if (matchOrigin) {\n    let protocolSource = protocol\n      ? tokensToRegExpSource(protocol, '', '.*', paramNames, true)\n      : '[^:]+'\n    let hostnameSource = hostname\n      ? tokensToRegExpSource(hostname, '.', '[^.]+?', paramNames, true)\n      : '[^/:]+'\n    let portSource = port !== undefined ? `:${regexpEscape(port)}` : '(?::[0-9]+)?'\n    let pathnameSource = pathname\n      ? tokensToRegExpSource(pathname, '/', '[^/]+?', paramNames, ignoreCase)\n      : ''\n\n    matcher = new RegExp(`^${protocolSource}://${hostnameSource}${portSource}/${pathnameSource}$`)\n  } else {\n    let pathnameSource = pathname\n      ? tokensToRegExpSource(pathname, '/', '[^/]+?', paramNames, ignoreCase)\n      : ''\n\n    matcher = new RegExp(`^/${pathnameSource}$`)\n  }\n\n  return { matchOrigin, matcher, paramNames }\n}\n\nfunction tokensToRegExpSource(\n  tokens: Token[],\n  sep: string,\n  paramRegExpSource: string,\n  paramNames: string[],\n  forceLowerCase: boolean,\n): string {\n  let source = ''\n\n  for (let token of tokens) {\n    if (token.type === 'variable') {\n      paramNames.push(token.name)\n      source += `(${paramRegExpSource})`\n    } else if (token.type === 'wildcard') {\n      if (token.name) {\n        paramNames.push(token.name)\n        source += `(.*)`\n      } else {\n        source += `(?:.*)`\n      }\n    } else if (token.type === 'text') {\n      source += regexpEscape(forceLowerCase ? token.value.toLowerCase() : token.value)\n    } else if (token.type === 'separator') {\n      source += regexpEscape(sep)\n    } else if (token.type === 'optional') {\n      source += `(?:${tokensToRegExpSource(token.tokens, sep, paramRegExpSource, paramNames, forceLowerCase)})?`\n    }\n  }\n\n  return source\n}\n\nfunction regexpEscape(text: string): string {\n  return text.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')\n}\n\nfunction matchSearch(search: string, constraints: SearchConstraints): boolean {\n  let { namesWithoutAssignment, namesWithAssignment, valuesByKey } = parseSearch(search)\n\n  for (let [key, constraint] of constraints) {\n    let hasAssigned = namesWithAssignment.has(key),\n      hasBare = namesWithoutAssignment.has(key),\n      values = valuesByKey.get(key)\n\n    if (constraint.requiredValues && constraint.requiredValues.size > 0) {\n      if (!values) return false\n      for (let value of constraint.requiredValues) {\n        if (!values.has(value)) return false\n      }\n      continue\n    }\n\n    if (constraint.requireAssignment) {\n      if (!hasAssigned) return false\n      continue\n    }\n\n    if (!(hasAssigned || hasBare)) return false\n  }\n\n  return true\n}\n", "import type { Matcher, MatchResult } from './matcher.ts'\nimport { RoutePattern } from './route-pattern.ts'\n\n/**\n * A simple array-based matcher that compiles route patterns to regular expressions.\n *\n * **Use RegExpMatcher when:**\n * - You have a single or handful of patterns\n * - Build time is critical (cold boot scenarios)\n * - Pattern set changes frequently (cheap to rebuild)\n * - Memory footprint needs to be minimal\n */\nexport class RegExpMatcher<T = any> implements Matcher<T> {\n  #pairs: { pattern: RoutePattern; data: T }[] = []\n  #count = 0\n\n  add<P extends string>(pattern: P | RoutePattern<P>, data: T): void {\n    let routePattern = typeof pattern === 'string' ? new RoutePattern(pattern) : pattern\n    this.#pairs.push({ pattern: routePattern, data })\n    this.#count++\n  }\n\n  match(url: string | URL): MatchResult<T> | null {\n    if (typeof url === 'string') url = new URL(url)\n\n    for (let { pattern, data } of this.#pairs) {\n      let match = pattern.match(url)\n      if (match) {\n        return { data, params: match.params, url: match.url }\n      }\n    }\n\n    return null\n  }\n\n  *matchAll(url: string | URL): Generator<MatchResult<T>> {\n    if (typeof url === 'string') url = new URL(url)\n\n    for (let { pattern, data } of this.#pairs) {\n      let match = pattern.match(url)\n      if (match) {\n        yield { data, params: match.params, url: match.url }\n      }\n    }\n  }\n\n  get size(): number {\n    return this.#count\n  }\n}\n", "import { RoutePattern } from '@remix-run/route-pattern'\nimport type { HrefBuilderArgs, Join, RouteMatch } from '@remix-run/route-pattern'\n\nimport type { RequestMethod } from './request-methods.ts'\nimport type { Simplify } from './type-utils.ts'\n\nexport interface RouteMap<T extends string = string> {\n  [K: string]: Route<RequestMethod | 'ANY', T> | RouteMap<T>\n}\n\nexport class Route<\n  M extends RequestMethod | 'ANY' = RequestMethod | 'ANY',\n  P extends string = string,\n> {\n  readonly method: M | 'ANY'\n  readonly pattern: RoutePattern<P>\n\n  constructor(method: M | 'ANY', pattern: P | RoutePattern<P>) {\n    this.method = method\n    this.pattern = typeof pattern === 'string' ? new RoutePattern(pattern) : pattern\n  }\n\n  href(...args: HrefBuilderArgs<P>): string {\n    return this.pattern.href(...args)\n  }\n\n  match(url: string | URL): RouteMatch<P> | null {\n    return this.pattern.match(url)\n  }\n}\n\n/**\n * Create a route map from a set of route definitions.\n */\nexport function createRoutes<const R extends RouteDefs>(defs: R): BuildRouteMap<'/', R>\nexport function createRoutes<P extends string, const R extends RouteDefs>(\n  base: P | RoutePattern<P>,\n  defs: R,\n): BuildRouteMap<P, R>\nexport function createRoutes(baseOrDefs: any, defs?: RouteDefs): RouteMap {\n  return typeof baseOrDefs === 'string' || baseOrDefs instanceof RoutePattern\n    ? buildRouteMap(\n        typeof baseOrDefs === 'string' ? new RoutePattern(baseOrDefs) : baseOrDefs,\n        defs!,\n      )\n    : buildRouteMap(new RoutePattern('/'), baseOrDefs)\n}\n\nfunction buildRouteMap<P extends string, R extends RouteDefs>(\n  base: RoutePattern<P>,\n  defs: R,\n): BuildRouteMap<P, R> {\n  let routes: any = {}\n\n  for (let key in defs) {\n    let def = defs[key]\n\n    if (def instanceof Route) {\n      routes[key] = new Route(def.method, base.join(def.pattern))\n    } else if (typeof def === 'string' || def instanceof RoutePattern) {\n      routes[key] = new Route('ANY', base.join(def))\n    } else if (typeof def === 'object' && def != null && 'pattern' in def) {\n      routes[key] = new Route((def as any).method ?? 'ANY', base.join((def as any).pattern))\n    } else {\n      routes[key] = buildRouteMap(base, def as any)\n    }\n  }\n\n  return routes\n}\n\n// prettier-ignore\nexport type BuildRouteMap<P extends string = string, R extends RouteDefs = RouteDefs> = Simplify<{\n  [K in keyof R]: (\n    R[K] extends Route<infer M extends RequestMethod | 'ANY', infer S extends string> ? Route<M, Join<P, S>> :\n    R[K] extends RouteDef ? BuildRoute<P, R[K]> :\n    R[K] extends RouteDefs ? BuildRouteMap<P, R[K]> :\n    never\n  )\n}>\n\n// prettier-ignore\ntype BuildRoute<P extends string, D extends RouteDef> = \n  D extends string ? Route<'ANY', Join<P, D>> :\n  D extends RoutePattern<infer S extends string> ? Route<'ANY', Join<P, S>> :\n  D extends { method: infer M, pattern: infer S } ? (\n    S extends string ? Route<M extends RequestMethod ? M : 'ANY', Join<P, S>> :\n    S extends RoutePattern<infer S extends string> ? Route<M extends RequestMethod ? M : 'ANY', Join<P, S>> :\n    never\n  ) :\n  never\n\nexport interface RouteDefs {\n  [K: string]: Route | RouteDef | RouteDefs\n}\n\nexport type RouteDef<T extends string = string> =\n  | T\n  | RoutePattern<T>\n  | { method?: RequestMethod; pattern: T | RoutePattern<T> }\n", "import type { RoutePattern } from '@remix-run/route-pattern'\n\nimport type { RequestMethod } from './request-methods.ts'\nimport { createRoutes } from './route-map.ts'\nimport type { BuildRouteMap } from './route-map.ts'\n\nexport interface FormActionOptions {\n  /**\n   * The method the `<form>` uses to submit the action.\n   * Default is `POST`.\n   */\n  formMethod?: RequestMethod\n  /**\n   * Custom names to use for the `index` and `action` routes.\n   */\n  names?: {\n    index?: string\n    action?: string\n  }\n}\n\n/**\n * Create a route map with `index` (`GET`) and `action` (`POST`) routes, suitable\n * for showing a standard HTML `<form>` and handling its submit action at the same\n * URL.\n *\n * @param pattern The route pattern to use for the form and its submit action\n */\nexport function createFormAction<P extends string, const O extends FormActionOptions>(\n  pattern: P | RoutePattern<P>,\n  options?: O,\n): BuildFormActionMap<P, O> {\n  let formMethod = options?.formMethod ?? 'POST'\n  let indexName = options?.names?.index ?? 'index'\n  let actionName = options?.names?.action ?? 'action'\n\n  return createRoutes(pattern, {\n    [indexName]: { method: 'GET', pattern: '/' },\n    [actionName]: { method: formMethod, pattern: '/' },\n  }) as BuildFormActionMap<P, O>\n}\n\n// prettier-ignore\ntype BuildFormActionMap<P extends string, O extends FormActionOptions> = BuildRouteMap<\n  P,\n  {\n    [\n      K in O extends { names: { index: infer I } }\n        ? I extends string\n          ? I\n          : 'index'\n        : 'index'\n    ]: {\n      method: 'GET'\n      pattern: '/'\n    }\n  } & {\n    [\n      K in O extends { names: { action: infer A } }\n        ? A extends string\n          ? A\n          : 'action'\n        : 'action'\n    ]: {\n      method: O extends { formMethod: infer M } ? M : 'POST'\n      pattern: '/'\n    }\n  }\n>\n", "import type { HrefBuilderArgs } from '@remix-run/route-pattern'\n\nimport type { Route } from './route-map.ts'\n\n/**\n * Creates an HTML Response with proper Content-Type header.\n *\n * @param body The body of the response\n * @param init Optional response initialization options\n * @returns A Response with HTML content-type header and the given body\n */\nexport function html(body: BodyInit, init?: ResponseInit): Response {\n  let headers = new Headers(init?.headers)\n  if (!headers.has('Content-Type')) {\n    headers.set('Content-Type', 'text/html; charset=UTF-8')\n  }\n\n  return new Response(body, { ...init, headers })\n}\n\n/**\n * Creates a JSON response with the given body and status code.\n *\n * @param body The body of the response, which will be `JSON.stringify`d\n * @param init Optional response initialization options\n * @returns A Response with JSON content-type header and the given body\n */\nexport function json(body: any, init?: ResponseInit): Response {\n  let headers = new Headers(init?.headers)\n  if (!headers.has('Content-Type')) {\n    headers.set('Content-Type', 'application/json; charset=UTF-8')\n  }\n\n  return new Response(JSON.stringify(body), { ...init, headers })\n}\n\n/**\n * Creates a redirect response with the given location and status code.\n *\n * Note: This improves upon `Response.redirect()` in the following ways:\n * - It accepts a `ResponseInit` object for fine-grained control over the response\n * - It accepts a Route object for type-safe redirects\n * - It accepts a relative URL for the location, which most HTTP clients\n *   will resolve against the base URL of the request\n *\n * @param location The location to redirect to (string or Route with no required params)\n * @param status The status code to redirect with, or a `ResponseInit` object. Defaults to `302`\n * @returns A Response that redirects to the given location\n */\nexport function redirect<P extends string>(\n  location: string | RouteWithNoRequiredParams<P>,\n  status: number | ResponseInit = 302,\n): Response {\n  let init: ResponseInit | undefined\n  if (typeof status !== 'number') {\n    init = status\n    status = 302\n  }\n\n  let href: string\n  if (typeof location === 'string') {\n    href = location\n  } else {\n    if (location.method !== 'GET' && location.method !== 'ANY') {\n      throw new Error('Route does not support GET')\n    }\n\n    href = location.href()\n  }\n\n  let headers = new Headers(init?.headers)\n  if (!headers.has('Location')) {\n    headers.set('Location', href)\n  }\n\n  return new Response(null, { status, ...init, headers })\n}\n\n/**\n * Type constraint for Routes that have no required parameters.\n * This ensures that calling `.href()` won't throw due to missing params.\n */\ntype RouteWithNoRequiredParams<P extends string> = Route<'GET' | 'ANY', P> & {\n  href: [] extends HrefBuilderArgs<P> ? () => string : never\n}\n", "/**\n * All HTTP request methods for requests that may have a body.\n */\nexport const RequestBodyMethods = ['POST', 'PUT', 'PATCH', 'DELETE', 'OPTIONS'] as const\nexport type RequestBodyMethod = (typeof RequestBodyMethods)[number]\n\n/**\n * All HTTP request methods that are supported by the router.\n */\nexport const RequestMethods = ['GET', 'HEAD', ...RequestBodyMethods] as const\nexport type RequestMethod = (typeof RequestMethods)[number]\n", "import type { RoutePattern } from '@remix-run/route-pattern'\n\nimport { createRoutes } from './route-map.ts'\nimport type { BuildRouteMap } from './route-map.ts'\n\nexport const ResourceMethods = ['new', 'show', 'create', 'edit', 'update', 'destroy'] as const\nexport type ResourceMethod = (typeof ResourceMethods)[number]\n\nexport interface ResourceOptions {\n  /**\n   * The resource methods to include in the route map. If not provided, all\n   * methods (`show`, `new`, `create`, `edit`, `update`, and `destroy`) will be\n   * included.\n   */\n  only?: ResourceMethod[]\n  /**\n   * Custom names to use for the resource routes.\n   */\n  names?: {\n    new?: string\n    show?: string\n    create?: string\n    edit?: string\n    update?: string\n    destroy?: string\n  }\n}\n\n/**\n * Create a route map with standard CRUD routes for a singleton resource.\n *\n * @param base The base route pattern to use for the resource\n * @param options Options to configure the resource routes\n */\nexport function createResource<P extends string, const O extends ResourceOptions>(\n  base: P | RoutePattern<P>,\n  options?: O,\n): BuildResourceMap<P, O> {\n  let only = options?.only ?? (ResourceMethods as readonly ResourceMethod[])\n  let newName = options?.names?.new ?? 'new'\n  let showName = options?.names?.show ?? 'show'\n  let createName = options?.names?.create ?? 'create'\n  let editName = options?.names?.edit ?? 'edit'\n  let updateName = options?.names?.update ?? 'update'\n  let destroyName = options?.names?.destroy ?? 'destroy'\n\n  let routes: any = {}\n\n  if (only.includes('new')) {\n    routes[newName] = { method: 'GET', pattern: `/new` }\n  }\n  if (only.includes('show')) {\n    routes[showName] = { method: 'GET', pattern: `/` }\n  }\n  if (only.includes('create')) {\n    routes[createName] = { method: 'POST', pattern: `/` }\n  }\n  if (only.includes('edit')) {\n    routes[editName] = { method: 'GET', pattern: `/edit` }\n  }\n  if (only.includes('update')) {\n    routes[updateName] = { method: 'PUT', pattern: `/` }\n  }\n  if (only.includes('destroy')) {\n    routes[destroyName] = { method: 'DELETE', pattern: `/` }\n  }\n\n  return createRoutes(base, routes) as BuildResourceMap<P, O>\n}\n\ntype BuildResourceMap<B extends string, O extends ResourceOptions> = BuildRouteMap<\n  B,\n  BuildResourceRoutes<\n    O,\n    O extends { only: readonly ResourceMethod[] } ? O['only'][number] : ResourceMethod\n  >\n>\n\ntype BuildResourceRoutes<O extends ResourceOptions, M extends ResourceMethod> = {\n  [K in M as GetRouteName<O, K>]: ResourceRoutes[K]\n}\n\ntype GetRouteName<O extends ResourceOptions, M extends ResourceMethod> = M extends ResourceMethod\n  ? O extends { names: { [K in M]: infer N extends string } }\n    ? N\n    : M\n  : never\n\ntype ResourceRoutes = {\n  new: { method: 'GET'; pattern: `/new` }\n  show: { method: 'GET'; pattern: `/` }\n  create: { method: 'POST'; pattern: `/` }\n  edit: { method: 'GET'; pattern: `/edit` }\n  update: { method: 'PUT'; pattern: `/` }\n  destroy: { method: 'DELETE'; pattern: `/` }\n}\n\n// prettier-ignore\nexport const ResourcesMethods = ['index', 'new', 'show', 'create', 'edit', 'update', 'destroy'] as const\nexport type ResourcesMethod = (typeof ResourcesMethods)[number]\n\nexport type ResourcesOptions = {\n  /**\n   * The resource methods to include in the route map. If not provided, all\n   * methods (`index`, `show`, `new`, `create`, `edit`, `update`, and `destroy`)\n   * will be included.\n   */\n  only?: ResourcesMethod[]\n  /**\n   * The parameter name to use for the resource. Defaults to `id`.\n   */\n  param?: string\n  /**\n   * Custom names to use for the resource routes.\n   */\n  names?: {\n    index?: string\n    new?: string\n    show?: string\n    create?: string\n    edit?: string\n    update?: string\n    destroy?: string\n  }\n}\n\n/**\n * Create a route map with standard CRUD routes for a resource collection.\n *\n * @param base The base route pattern to use for the resources\n * @param options Options to configure the resource routes\n */\nexport function createResources<P extends string, const O extends ResourcesOptions>(\n  base: P | RoutePattern<P>,\n  options?: O,\n): BuildResourcesMap<P, O> {\n  let only = options?.only ?? (ResourcesMethods as readonly ResourcesMethod[])\n  let param = options?.param ?? 'id'\n  let indexName = options?.names?.index ?? 'index'\n  let newName = options?.names?.new ?? 'new'\n  let showName = options?.names?.show ?? 'show'\n  let createName = options?.names?.create ?? 'create'\n  let editName = options?.names?.edit ?? 'edit'\n  let updateName = options?.names?.update ?? 'update'\n  let destroyName = options?.names?.destroy ?? 'destroy'\n\n  let routes: any = {}\n\n  if (only.includes('index')) {\n    routes[indexName] = { method: 'GET', pattern: `/` }\n  }\n  if (only.includes('new')) {\n    routes[newName] = { method: 'GET', pattern: `/new` }\n  }\n  if (only.includes('show')) {\n    routes[showName] = { method: 'GET', pattern: `/:${param}` }\n  }\n  if (only.includes('create')) {\n    routes[createName] = { method: 'POST', pattern: `/` }\n  }\n  if (only.includes('edit')) {\n    routes[editName] = { method: 'GET', pattern: `/:${param}/edit` }\n  }\n  if (only.includes('update')) {\n    routes[updateName] = { method: 'PUT', pattern: `/:${param}` }\n  }\n  if (only.includes('destroy')) {\n    routes[destroyName] = { method: 'DELETE', pattern: `/:${param}` }\n  }\n\n  return createRoutes(base, routes) as BuildResourcesMap<P, O>\n}\n\ntype BuildResourcesMap<B extends string, O extends ResourcesOptions> = BuildRouteMap<\n  B,\n  BuildResourcesRoutes<\n    O,\n    O extends { only: readonly ResourcesMethod[] } ? O['only'][number] : ResourcesMethod,\n    GetParam<O>\n  >\n>\n\ntype BuildResourcesRoutes<\n  O extends ResourcesOptions,\n  M extends ResourcesMethod,\n  Param extends string,\n> = {\n  [K in M as GetResourcesRouteName<O, K>]: ResourcesRoutes<Param>[K]\n}\n\ntype GetResourcesRouteName<\n  O extends ResourcesOptions,\n  M extends ResourcesMethod,\n> = M extends ResourcesMethod\n  ? O extends { names: { [K in M]: infer N extends string } }\n    ? N\n    : M\n  : never\n\ntype ResourcesRoutes<Param extends string> = {\n  index: { method: 'GET'; pattern: `/` }\n  new: { method: 'GET'; pattern: `/new` }\n  show: { method: 'GET'; pattern: `/:${Param}` }\n  create: { method: 'POST'; pattern: `/` }\n  edit: { method: 'GET'; pattern: `/:${Param}/edit` }\n  update: { method: 'PUT'; pattern: `/:${Param}` }\n  destroy: { method: 'DELETE'; pattern: `/:${Param}` }\n}\n\ntype GetParam<O extends ResourcesOptions> = O extends { param: infer P extends string } ? P : 'id'\n", "import type { RequestContext } from './request-context.ts'\nimport type { RequestHandler } from './request-handler.ts'\nimport type { RequestMethod } from './request-methods.ts'\n\n/**\n * A special kind of request handler that either returns a response or passes control\n * to the next middleware or request handler in the chain.\n */\nexport interface Middleware<\n  Method extends RequestMethod | 'ANY' = RequestMethod | 'ANY',\n  Params extends Record<string, any> = {},\n> {\n  (\n    context: RequestContext<Method, Params>,\n    next: NextFunction,\n  ): Response | undefined | void | Promise<Response | undefined | void>\n}\n\nexport type NextFunction = (moreContext?: Partial<RequestContext>) => Promise<Response>\n\nexport function runMiddleware<\n  Method extends RequestMethod | 'ANY' = RequestMethod | 'ANY',\n  Params extends Record<string, any> = {},\n>(\n  middleware: Middleware<Method, Params>[],\n  context: RequestContext<Method, Params>,\n  handler: RequestHandler<Method, Params, Response>,\n): Promise<Response> {\n  let index = -1\n\n  let dispatch = async (i: number): Promise<Response> => {\n    if (i <= index) throw new Error('next() called multiple times')\n    index = i\n\n    let fn = middleware[i]\n    if (!fn) return handler(context)\n\n    let nextPromise: Promise<Response> | undefined\n    let next: NextFunction = (moreContext?: Partial<RequestContext>) => {\n      if (moreContext != null) {\n        Object.assign(context, moreContext)\n      }\n\n      nextPromise = dispatch(i + 1)\n      return nextPromise\n    }\n\n    let response = await fn(context, next)\n\n    // If a response was returned, short-circuit the chain\n    if (response instanceof Response) {\n      return response\n    }\n\n    // If the middleware called next(), use the downstream response\n    if (nextPromise != null) {\n      return nextPromise\n    }\n\n    // If it did not call next(), invoke downstream automatically\n    return next()\n  }\n\n  return dispatch(0)\n}\n", "import { AppStorage } from './app-storage.ts'\nimport type { RequestBodyMethod, RequestMethod } from './request-methods.ts'\n\n/**\n * A context object that contains information about the current request. Every request\n * handler or middleware in the lifecycle of a request receives the same context object.\n */\nexport class RequestContext<\n  Method extends RequestMethod | 'ANY' = RequestMethod | 'ANY',\n  Params extends Record<string, any> = {},\n> {\n  /**\n   * Parsed [`FormData`](https://developer.mozilla.org/en-US/docs/Web/API/FormData) from the request body.\n   *\n   * Note: This is only available for requests with a body (not `GET` or `HEAD`).\n   *\n   * [MDN Reference](https://developer.mozilla.org/en-US/docs/Web/API/FormData)\n   */\n  formData: Method extends RequestBodyMethod ? FormData : undefined\n  /**\n   * The request method. This may differ from `request.method` if the request body\n   * contained a method override field (e.g. `_method=DELETE`), allowing HTML forms to simulate\n   * RESTful API request methods like PUT and DELETE.\n   */\n  method: RequestMethod\n  /**\n   * Params that were parsed from the URL.\n   */\n  params: Params\n  /**\n   * The original request that was dispatched to the router.\n   */\n  request: Request\n  /**\n   * Shared application-specific storage.\n   */\n  storage: AppStorage\n  /**\n   * The URL that was matched by the route.\n   *\n   * Note: This may be different from `request.url` if the request was routed to a\n   * sub-router, in which case the URL mount point is stripped from the pathname.\n   */\n  url: URL\n\n  constructor(request: Request) {\n    this.formData = undefined as any\n    this.method = request.method.toUpperCase() as RequestMethod\n    this.params = {} as Params\n    this.request = request\n    this.storage = new AppStorage()\n    this.url = new URL(request.url)\n  }\n\n  /**\n   * The headers of the request.\n   */\n  get headers(): Headers {\n    // TODO: Make this a SuperHeaders object?\n    return this.request.headers\n  }\n\n  /**\n   * Files that were uploaded in the request body, in a map.\n   */\n  get files(): Map<string, File> | null {\n    let formData = this.formData\n\n    if (formData == null) {\n      return null\n    }\n\n    let files: Map<string, File> = new Map()\n\n    for (let [key, value] of formData.entries()) {\n      if (value instanceof File) {\n        files.set(key, value)\n      }\n    }\n\n    return files\n  }\n}\n", "import type { Params } from '@remix-run/route-pattern'\n\nimport type { Middleware } from './middleware.ts'\nimport type { RequestHandler } from './request-handler.ts'\nimport type { RequestMethod } from './request-methods.ts'\nimport type { Route, RouteMap } from './route-map.ts'\n\n// prettier-ignore\nexport type RouteHandlers<T extends RouteMap> =\n  | RouteHandlersWithMiddleware<T>\n  | {\n      [K in keyof T]: (\n        T[K] extends Route<infer M, infer P> ? RouteHandler<M, P> :\n        T[K] extends RouteMap ? RouteHandlers<T[K]> :\n        never\n      )\n    }\n\ntype RouteHandlersWithMiddleware<T extends RouteMap> = {\n  use: Middleware[]\n  handlers: RouteHandlers<T>\n}\n\nexport function isRouteHandlersWithMiddleware<T extends RouteMap>(\n  handlers: any,\n): handlers is RouteHandlersWithMiddleware<T> {\n  return (\n    typeof handlers === 'object' && handlers != null && 'use' in handlers && 'handlers' in handlers\n  )\n}\n\n/**\n * Infer the route handler type from a route or string.\n */\n// prettier-ignore\nexport type InferRouteHandler<T extends Route | string> =\n  T extends Route<infer M, infer P> ? RouteHandler<M, P> :\n  T extends string ? RouteHandler<'ANY', T> :\n  never\n\n/**\n * An individual route handler.\n */\nexport type RouteHandler<M extends RequestMethod | 'ANY', T extends string> =\n  | RequestHandlerWithMiddleware<M, T>\n  | RequestHandler<M, Params<T>>\n\ntype RequestHandlerWithMiddleware<M extends RequestMethod | 'ANY', T extends string> = {\n  use: Middleware<M, Params<T>>[]\n  handler: RequestHandler<M, Params<T>>\n}\n\nexport function isRequestHandlerWithMiddleware<M extends RequestMethod | 'ANY', T extends string>(\n  handler: any,\n): handler is RequestHandlerWithMiddleware<M, T> {\n  return typeof handler === 'object' && handler != null && 'use' in handler && 'handler' in handler\n}\n", "import { FormDataParseError, parseFormData } from '@remix-run/form-data-parser'\nimport type { ParseFormDataOptions, FileUploadHandler } from '@remix-run/form-data-parser'\nimport { RegExpMatcher, RoutePattern } from '@remix-run/route-pattern'\nimport type { Matcher } from '@remix-run/route-pattern'\n\nimport { runMiddleware } from './middleware.ts'\nimport type { Middleware } from './middleware.ts'\nimport { RequestContext } from './request-context.ts'\nimport type { RequestHandler } from './request-handler.ts'\nimport { RequestBodyMethods } from './request-methods.ts'\nimport type { RequestBodyMethod, RequestMethod } from './request-methods.ts'\nimport { isRequestHandlerWithMiddleware, isRouteHandlersWithMiddleware } from './route-handlers.ts'\nimport type { RouteHandlers, InferRouteHandler } from './route-handlers.ts'\nimport { Route } from './route-map.ts'\nimport type { RouteMap } from './route-map.ts'\n\nexport interface RouterOptions {\n  /**\n   * The default request handler that runs when no route matches.\n   * Default is a 404 \"Not Found\" response.\n   */\n  defaultHandler?: RequestHandler\n  /**\n   * The matcher to use for matching routes.\n   * Default is a `new RegExpMatcher()`.\n   */\n  matcher?: Matcher<MatchData>\n  /**\n   * The name of the form field to check for request method override. Default is `_method`.\n   * Set `false` to disable method override support.\n   */\n  methodOverride?: string | boolean\n  /**\n   * Options for parsing form data.\n   * Set `false` to disable form data parsing.\n   */\n  parseFormData?: (ParseFormDataOptions & { suppressErrors?: boolean }) | boolean\n  /**\n   * A function that handles file uploads. It receives a `FileUpload` object and may return any\n   * value that is a valid `FormData` value.\n   */\n  uploadHandler?: FileUploadHandler\n}\n\ntype MatchData =\n  | {\n      method: RequestMethod | 'ANY'\n      middleware: Middleware<any>[] | undefined\n      handler: RequestHandler<any>\n    }\n  | {\n      middleware: Middleware<any>[] | undefined\n      prefix: string\n      router: Router\n    }\n\nfunction noMatchHandler({ url }: RequestContext): Response {\n  return new Response(`Not Found: ${url.pathname}`, { status: 404 })\n}\n\n/**\n * Create a new router.\n */\nexport function createRouter(options?: RouterOptions): Router {\n  return new Router(options)\n}\n\nexport class Router {\n  #defaultHandler: RequestHandler\n  #matcher: Matcher<MatchData>\n  #middleware: Middleware[] | undefined\n  #parseFormData: (ParseFormDataOptions & { suppressErrors?: boolean }) | boolean\n  #uploadHandler: FileUploadHandler | undefined\n  #methodOverride: string | boolean\n\n  constructor(options?: RouterOptions) {\n    this.#defaultHandler = options?.defaultHandler ?? noMatchHandler\n    this.#matcher = options?.matcher ?? new RegExpMatcher()\n    this.#parseFormData = options?.parseFormData ?? true\n    this.#uploadHandler = options?.uploadHandler\n    this.#methodOverride = options?.methodOverride ?? true\n  }\n\n  /**\n   * Fetch a response from the router.\n   */\n  async fetch(input: string | URL | Request, init?: RequestInit): Promise<Response> {\n    let request = input instanceof Request ? input : new Request(input, init)\n\n    let response = await this.dispatch(request)\n    if (response == null) {\n      response = await this.#defaultHandler(new RequestContext(request))\n    }\n\n    return response\n  }\n\n  /**\n   * Low-level method that runs a request through the router and returns a response or null if no\n   * match is found.\n   *\n   * Note: This method does not invoke the router's default handler when no match is found. If\n   * that's what you want, use `router.fetch()` instead.\n   */\n  async dispatch(\n    request: Request | RequestContext,\n    upstreamMiddleware?: Middleware[],\n  ): Promise<Response | null> {\n    let context = request instanceof Request ? await this.#parseRequest(request) : request\n\n    for (let match of this.#matcher.matchAll(context.url)) {\n      if ('router' in match.data) {\n        // Matched a sub-router, try to dispatch to it\n        let { middleware: mountMiddleware, prefix, router } = match.data\n\n        // Save original URL and create new URL with stripped pathname\n        let originalUrl = context.url\n        let strippedUrl = new URL(match.url)\n        strippedUrl.pathname = strippedUrl.pathname.slice(prefix.length)\n        context.url = strippedUrl\n\n        let response = await router.dispatch(\n          context,\n          // For mounts, pass upstream + mount middleware\n          concatMiddleware(upstreamMiddleware, mountMiddleware),\n        )\n\n        // Always restore original URL\n        context.url = originalUrl\n\n        if (response != null) {\n          return response\n        }\n\n        // No match in sub-router, continue to next match\n        continue\n      }\n\n      let { method, middleware: routeMiddleware, handler } = match.data\n\n      if (method !== context.method && method !== 'ANY') {\n        continue\n      }\n\n      context.params = match.params\n      context.url = match.url\n\n      let middleware = concatMiddleware(upstreamMiddleware, routeMiddleware)\n      return middleware != null\n        ? await runMiddleware(middleware, context, handler)\n        : await handler(context)\n    }\n\n    return null\n  }\n\n  async #parseRequest(request: Request): Promise<RequestContext> {\n    let context = new RequestContext(request)\n\n    if (this.#parseFormData === false) {\n      return context\n    }\n\n    if (shouldParseFormData(request)) {\n      let suppressParseErrors: boolean\n      let parseOptions: ParseFormDataOptions\n      if (this.#parseFormData === true) {\n        suppressParseErrors = false\n        parseOptions = {}\n      } else {\n        suppressParseErrors = this.#parseFormData.suppressErrors ?? false\n        parseOptions = this.#parseFormData\n      }\n\n      try {\n        context.formData = await parseFormData(request, parseOptions, this.#uploadHandler)\n      } catch (error) {\n        if (!suppressParseErrors || !(error instanceof FormDataParseError)) {\n          throw error\n        }\n\n        // Suppress parse error, continue with empty formData\n        context.formData = new FormData()\n      }\n    } else {\n      // No form data to parse, continue with empty formData\n      context.formData = new FormData()\n    }\n\n    if (this.#methodOverride) {\n      let fieldName = this.#methodOverride === true ? '_method' : this.#methodOverride\n      let methodOverride = context.formData.get(fieldName)\n      if (typeof methodOverride === 'string' && methodOverride !== '') {\n        context.method = methodOverride.toUpperCase() as RequestMethod\n      }\n    }\n\n    return context\n  }\n\n  /**\n   * Mount a router at a given pathname prefix in the current router.\n   */\n  mount(router: Router): void\n  mount(pathnamePrefix: string, router: Router): void\n  mount(arg: string | Router, router?: Router): void {\n    let pathnamePrefix = '/'\n    if (typeof arg === 'string') {\n      if (!arg.startsWith('/') || arg.includes('?') || arg.includes(':') || arg.includes('*')) {\n        throw new Error(\n          `Invalid mount prefix: \"${arg}\"; prefix must start with \"/\" and contain only static segments`,\n        )\n      }\n\n      pathnamePrefix = arg\n    } else {\n      router = arg\n    }\n\n    // Add an optional catch-all segment so the pattern matches any pathname\n    // that starts with the prefix.\n    let pattern = pathnamePrefix.replace(/\\/*$/, '(/*)')\n\n    this.#matcher.add(pattern, {\n      middleware: this.#middleware,\n      prefix: pathnamePrefix,\n      router: router!,\n    })\n  }\n\n  /**\n   * Add middleware to the router.\n   */\n  use(middleware: Middleware | Middleware[]): void {\n    this.#middleware = (this.#middleware ?? []).concat(middleware)\n  }\n\n  /**\n   * The number of routes in the router.\n   */\n  get size(): number {\n    return this.#matcher.size\n  }\n\n  // Route mapping\n\n  route<M extends RequestMethod | 'ANY', P extends string>(\n    method: M,\n    pattern: P | RoutePattern<P> | Route<M | 'ANY', P>,\n    handler: InferRouteHandler<P>,\n  ): void {\n    let routeMiddleware: Middleware[] | undefined\n    let requestHandler: RequestHandler\n    if (isRequestHandlerWithMiddleware(handler)) {\n      routeMiddleware = handler.use\n      requestHandler = handler.handler\n    } else {\n      requestHandler = handler\n    }\n\n    this.#matcher.add(pattern instanceof Route ? pattern.pattern : pattern, {\n      method,\n      middleware: concatMiddleware(this.#middleware, routeMiddleware),\n      handler: requestHandler,\n    })\n  }\n\n  map<M extends RequestMethod | 'ANY', P extends string>(\n    route: P | RoutePattern<P> | Route<M, P>,\n    handler: InferRouteHandler<P>,\n  ): void\n  map<T extends RouteMap>(routes: T, handlers: RouteHandlers<T>): void\n  map(routeOrRoutes: any, handler: any): void {\n    if (typeof routeOrRoutes === 'string' || routeOrRoutes instanceof RoutePattern) {\n      // map(pattern, handler)\n      this.route('ANY', routeOrRoutes, handler)\n    } else if (routeOrRoutes instanceof Route) {\n      // map(route, handler)\n      this.route(routeOrRoutes.method, routeOrRoutes.pattern, handler)\n    } else if (isRouteHandlersWithMiddleware(handler)) {\n      // map(routes, { use, handlers })\n      let use = handler.use\n      let handlers = handler.handlers\n      for (let key in routeOrRoutes) {\n        let route = routeOrRoutes[key]\n        let handler = (handlers as any)[key]\n\n        if (route instanceof Route) {\n          if (isRequestHandlerWithMiddleware(handler)) {\n            this.route(route.method, route.pattern, {\n              use: use.concat(handler.use),\n              handler: handler.handler,\n            })\n          } else {\n            this.route(route.method, route.pattern, { use, handler })\n          }\n        } else if (isRouteHandlersWithMiddleware(handler)) {\n          this.map(route, { use: use.concat(handler.use), handlers: handler.handlers })\n        } else {\n          this.map(route, { use, handlers: handler })\n        }\n      }\n    } else {\n      // map(routes, handlers)\n      let handlers = handler\n      for (let key in routeOrRoutes) {\n        let route = routeOrRoutes[key]\n        let handler = handlers[key]\n\n        if (route instanceof Route) {\n          this.route(route.method, route.pattern, handler)\n        } else {\n          this.map(route, handler)\n        }\n      }\n    }\n  }\n\n  // HTTP-method specific shorthand\n\n  get<P extends string>(\n    pattern: P | RoutePattern<P> | Route<'GET' | 'ANY', P>,\n    handler: InferRouteHandler<P>,\n  ): void {\n    this.route('GET', pattern, handler)\n  }\n\n  head<P extends string>(\n    pattern: P | RoutePattern<P> | Route<'HEAD' | 'ANY', P>,\n    handler: InferRouteHandler<P>,\n  ): void {\n    this.route('HEAD', pattern, handler)\n  }\n\n  post<P extends string>(\n    pattern: P | RoutePattern<P> | Route<'POST' | 'ANY', P>,\n    handler: InferRouteHandler<P>,\n  ): void {\n    this.route('POST', pattern, handler)\n  }\n\n  put<P extends string>(\n    pattern: P | RoutePattern<P> | Route<'PUT' | 'ANY', P>,\n    handler: InferRouteHandler<P>,\n  ): void {\n    this.route('PUT', pattern, handler)\n  }\n\n  patch<P extends string>(\n    pattern: P | RoutePattern<P> | Route<'PATCH' | 'ANY', P>,\n    handler: InferRouteHandler<P>,\n  ): void {\n    this.route('PATCH', pattern, handler)\n  }\n\n  delete<P extends string>(\n    pattern: P | RoutePattern<P> | Route<'DELETE' | 'ANY', P>,\n    handler: InferRouteHandler<P>,\n  ): void {\n    this.route('DELETE', pattern, handler)\n  }\n\n  options<P extends string>(\n    pattern: P | RoutePattern<P> | Route<'OPTIONS' | 'ANY', P>,\n    handler: InferRouteHandler<P>,\n  ): void {\n    this.route('OPTIONS', pattern, handler)\n  }\n}\n\nfunction shouldParseFormData(request: Request): boolean {\n  if (!RequestBodyMethods.includes(request.method as RequestBodyMethod)) {\n    return false\n  }\n\n  let contentType = request.headers.get('Content-Type')\n\n  return (\n    contentType != null &&\n    (contentType.startsWith('multipart/') ||\n      contentType.startsWith('application/x-www-form-urlencoded'))\n  )\n}\n\nfunction concatMiddleware(\n  a: Middleware[] | undefined,\n  b: Middleware[] | undefined,\n): Middleware[] | undefined {\n  return a == null ? b : b == null ? a : a.concat(b)\n}\n", "import { route, resources } from '@remix-run/fetch-router'\n\nexport let routes = route({\n  assets: '/assets/*path',\n  home: resources('/', { only: [ 'index' ]}),\n  authors: resources('/authors', { only: [ 'index', 'show', 'new', 'create', 'destroy' ]})\n})", null, "import { press } from \"@remix-run/events/press\";\nimport { type Remix, hydrated } from '@remix-run/dom'\nimport { routes } from \"src/routes.ts\";\n\nexport const Counter =  hydrated(\n  routes.assets.href({ path: \"Counter.js#Counter\" }),\n  function(this: Remix.Handle, {}) {\n  let counter = 0\n\n  let add = () => {\n    counter = counter + 1\n    this.update()\n  }\n\n  return () => (\n    <div>\n      <p>Count: {counter}</p>\n      <button on={press(() => add())}>Add</button>\n    </div>\n  );\n})"],
  "mappings": "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",
  "names": ["createEventNameWithOptions", "baseName", "options", "params", "sortedKeys", "key", "createInteraction", "eventName", "factory", "handler", "_debug", "log", "args", "_debug", "events", "target", "initialDescriptors", "descriptors", "cleanups", "on", "nextDescriptors", "descriptorsChanged", "cleanupAll", "attachAllEvents", "updateHandlersInPlace", "cleanup", "bind", "type", "handler", "options", "shallowEqual", "a", "b", "keysA", "keysB", "key", "createDispatcher", "originalEvent", "customEvent", "originalStopPropagation", "prepareInteractions", "seenEventTypes", "descriptor", "dispatch", "factoryResult", "factoryCleanups", "attach", "eventType", "preventedEvents", "controller", "wrappedHandler", "event", "call", "e", "attachStandardEvents", "eventsByType", "attachInteractions", "byType", "custom", "standard", "splitDescriptors", "isInteractionDescriptor", "i", "current", "next", "createTargetProxy", "type", "handler", "options", "bind", "target", "prop", "dom", "xhr", "win", "doc", "ws", "invariant", "assertion", "message", "prefix", "normalizeBox", "box", "defaultValue", "isTargetWithinHitBox", "element", "event", "options", "rect", "hit", "isTargetWithinReleaseBox", "release", "totalBox", "dispatchedPressDownEvents", "pressDown", "createInteraction", "dispatch", "target", "pointerDownHandler", "e", "bubbles", "keyDownHandler", "pointerUpHandler", "events", "doc", "dom", "pressUp", "dispatchedPressUpEvents", "keyUpHandler", "longPress", "timer", "startDetail", "activePointers", "clearTimer", "startHandler", "invariant", "endHandler", "pointerMoveHandler", "dispatchedPressEvents", "press", "pressing", "longPressed", "longPressHandler", "originalEvent", "outerPressDown", "outerPressUp", "pressed", "startEvent", "outerPress", "createSearch", "pattern", "needle", "search", "haystack", "start", "needleEnd", "skipTable", "i", "haystackLength", "j", "k", "findDoubleNewline", "createSearch", "oneKb", "oneMb", "decoder", "split", "source", "protocol", "hostname", "port", "pathname", "search", "searchStart", "index", "solidusIndex", "hostEndIndex", "colonIndex", "isPort", "i", "char", "parseSearchConstraints", "constraints", "part", "eqIndex", "name", "decodeSearchComponent", "valuePart", "existing", "decodedValue", "parseSearch", "namesWithoutAssignment", "namesWithAssignment", "valuesByKey", "value", "set", "text", "ParseError", "description", "partName", "position", "parse", "searchConstraints", "ranges", "parsePart", "identifierMatcher", "sep", "start", "end", "tokens", "currentTokens", "tokensStack", "openIndexes", "appendText", "lastToken", "remaining", "next", "MissingParamError", "paramName", "formatHref", "parsed", "params", "searchParams", "href", "resolveTokens", "str", "token", "error", "stringify", "stringifyTokens", "startsWithSeparator", "stringifySearchConstraints", "firstToken", "parts", "key", "requiredValue", "join", "a", "b", "joinPathnames", "joinSearchConstraints", "inputStartsWithSeparator", "baseSearch", "inputSearch", "merged", "inputConstraint", "baseConstraint", "mergedConstraint", "RoutePattern", "_RoutePattern", "#parsed", "#compiled", "options", "args", "input", "parsedInput", "url", "matchOrigin", "matcher", "paramNames", "#compile", "match", "matchSearch", "compilePattern", "ignoreCase", "protocolSource", "tokensToRegExpSource", "hostnameSource", "portSource", "regexpEscape", "pathnameSource", "paramRegExpSource", "forceLowerCase", "constraint", "hasAssigned", "hasBare", "values", "Route", "method", "pattern", "RoutePattern", "args", "url", "createRoutes", "baseOrDefs", "defs", "buildRouteMap", "base", "routes", "key", "def", "RequestBodyMethods", "RequestMethods", "ResourcesMethods", "createResources", "base", "options", "only", "param", "indexName", "newName", "showName", "createName", "editName", "updateName", "destroyName", "routes", "createRoutes", "routes", "createRoutes", "createResources", "jsx", "type", "props", "key", "jsxAdapter", "jsxs", "jsxAdapter", "type", "props", "key", "createElement", "Counter", "hydrated", "routes", "counter", "add", "jsxs", "jsx", "press"]
}
