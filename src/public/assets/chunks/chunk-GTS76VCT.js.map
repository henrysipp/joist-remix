{
  "version": 3,
  "sources": ["../../../../node_modules/@remix-run/dom/src/lib/hydrated.ts", "../../../../node_modules/@remix-run/dom/src/lib/component.ts", "../../../../node_modules/@remix-run/dom/src/lib/invariant.ts", "../../../../node_modules/@remix-run/dom/src/lib/diff-dom.ts", "../../../../node_modules/@remix-run/events/src/lib/events.ts", "../../../../node_modules/@remix-run/events/src/lib/targets.ts", "../../../../node_modules/@remix-run/events/src/lib/interactions.ts", "../../../../node_modules/@remix-run/events/src/lib/event-type.ts", "../../../../node_modules/@remix-run/style/src/lib/style.ts", "../../../../node_modules/@remix-run/style/src/lib/stylesheet.ts", "../../../../node_modules/@remix-run/dom/src/lib/vdom.ts", "../../../../node_modules/@remix-run/dom/src/lib/frame.ts"],
  "sourcesContent": ["import type { Remix } from './component.ts'\n\n/**\n * Serializable primitive types that can be passed as props to hydrated components\n */\nexport type SerializablePrimitive = string | number | boolean | null | undefined\n\n/**\n * Serializable object types that can be passed as props to hydrated components\n */\nexport type SerializableObject = {\n  [key: string]: SerializableValue\n}\n\n/**\n * Serializable array types that can be passed as props to hydrated components\n */\nexport type SerializableArray = SerializableValue[]\n\n/**\n * All serializable values that can be passed as props to hydrated components.\n * This includes primitives, objects, arrays, and Remix Elements.\n */\nexport type SerializableValue =\n  | SerializablePrimitive\n  | SerializableObject\n  | SerializableArray\n  | Remix.RemixNode\n\n/**\n * Props that can be serialized and sent to hydrated components.\n * All values must be serializable (primitives, objects, arrays, or Remix Elements).\n */\nexport type SerializableProps = {\n  [K in string]: SerializableValue\n}\n\n// Whitelist of allowed simple component return types (non-function)\ntype SimpleRenderable = Element | string | number | bigint | boolean | null | undefined\n\n/**\n * Metadata added to hydrated components\n */\nexport type HydrationMetadata = {\n  $hydrated: true\n  $moduleUrl: string\n  $exportName: string\n}\n\n/**\n * A hydrated component preserves the exact function type with added metadata\n */\nexport type HydratedComponent<\n  H extends (this: Remix.Handle, props: any) => any = (this: Remix.Handle, props: any) => any,\n> = H & HydrationMetadata\n\n/**\n * Marks a component for client-side hydration.\n *\n * @param href Module URL with optional export name (format: \"/js/module.js#ExportName\")\n * @param component Component function that will be hydrated on the client\n * @returns The component augmented with hydration metadata\n *\n * @example\n * ```tsx\n * export const Counter = hydrated(\n *   '/js/counter.js#Counter',\n *   function (this: Handle, { initialCount }: { initialCount: number }) {\n *     let count = initialCount\n *\n *     return ({ label }: { label: string }) => (\n *       <button\n *         type=\"button\"\n *         on={dom.click(() => {\n *           count++\n *           this.render()\n *         })}\n *       >\n *         {label} {count}\n *       </button>\n *     )\n *   }\n * )\n * ```\n */\n// Overload for stateful components (setup returns render function)\nexport function hydrated<\n  SetupProps extends SerializableProps = {},\n  RenderProps extends SerializableProps = {},\n>(\n  href: string,\n  component: (this: Remix.Handle, props: SetupProps) => (props: RenderProps) => Remix.RemixNode,\n): HydratedComponent<\n  (this: Remix.Handle, props: SetupProps) => (props: RenderProps) => Remix.RemixNode\n>\n\n// Overload for simple components (setup returns JSX directly)\nexport function hydrated<\n  Props extends SerializableProps = {},\n  Render extends SimpleRenderable = SimpleRenderable,\n>(\n  href: string,\n  component: (this: Remix.Handle, props: Props) => Render,\n): HydratedComponent<(this: Remix.Handle, props: Props) => Render>\n\n// Implementation\nexport function hydrated(href: string, component: any): any {\n  // Parse module URL and export name\n  let [moduleUrl, exportName] = href.split('#')\n\n  if (!moduleUrl) {\n    throw new Error('hydrated() requires a module URL')\n  }\n\n  // Use component name as fallback if no export name provided\n  let finalExportName = exportName || component.name\n\n  if (!finalExportName) {\n    throw new Error(\n      'hydrated() requires either an export name in the href (e.g., \"/js/module.js#ComponentName\") or a named component function',\n    )\n  }\n\n  // Augment the component with hydration metadata\n  component.$hydrated = true\n  component.$moduleUrl = moduleUrl\n  component.$exportName = finalExportName\n\n  return component\n}\n\n/**\n * Type guard to check if a component is hydrated\n */\nexport function isHydratedComponent<H extends (this: Remix.Handle, props: any) => any>(\n  component: any,\n): component is HydratedComponent<H> {\n  return Boolean(component && typeof component === 'function' && component.$hydrated === true)\n}\n", "import type { EventDescriptor } from '@remix-run/events'\n\nexport namespace Remix {\n  /**\n   * Any valid element type accepted by JSX or `createElement`.\n   * - `string` for host elements (e.g., 'div')\n   * - `Function` for user components\n   */\n  export type ElementType = string | Function\n\n  /**\n   * Generic bag of props passed to elements/components.\n   * Consumers should define specific prop types on their components; this is the\n   * renderer's normalized shape used throughout reconciler/SSR code.\n   */\n  export type ElementProps = Record<string, any>\n\n  /**\n   * A virtual element produced by JSX/`createElement` describing UI.  Carries a\n   * `$rmx` brand used to distinguish it from plain objects at runtime.\n   */\n  export interface RemixElement {\n    type: ElementType\n    props: ElementProps\n    $rmx: true\n  }\n\n  /**\n   * Any single value Remix can render. Booleans render as empty text.\n   */\n  export type Renderable = RemixElement | string | number | bigint | boolean | null | undefined\n\n  /**\n   * Anything that Remix can render, including arrays of renderable values.\n   * Particularly useful for `props.children`.\n   *\n   * ```tsx\n   * function MyComponent({ children }: { children: RemixNode }) {}\n   * ```\n   */\n  export type RemixNode = Renderable | Renderable[]\n\n  export type Task = (signal: AbortSignal) => void\n\n  export interface Handle<C = Record<string, never>> {\n    id: string\n    context: Context<C>\n    render(task?: Task): void\n    queueTask(task: Task): void\n    raise(error: unknown): void\n    frame: FrameHandle\n    disconnectedSignal: AbortSignal\n  }\n\n  /**\n   * Default Handle context so types must be declared explicitly.\n   */\n  export type NoContext = Record<string, never>\n\n  export type Component<\n    Context = NoContext,\n    SetupProps = ElementProps,\n    RenderProps = ElementProps,\n  > = (this: Handle<Context>, props: SetupProps) => RemixNode | ((props: RenderProps) => RemixNode)\n\n  export type ContextFrom<ComponentType> =\n    ComponentType extends Component<infer Provided, any, any>\n      ? Provided\n      : ComponentType extends (this: Handle<infer Provided>, ...args: any[]) => any\n        ? Provided\n        : never\n\n  export interface Context<C> {\n    set(values: C): void\n    get<ComponentType>(component: ComponentType): ContextFrom<ComponentType>\n    get(component: ElementType | symbol): unknown | undefined\n  }\n\n  // export type FrameContent = RemixElement | Element | DocumentFragment | ReadableStream | string\n  export type FrameContent = DocumentFragment | string\n\n  export type FrameHandle = EventTarget & {\n    reload(): Promise<void>\n    replace(content: FrameContent): Promise<void>\n  }\n\n  export interface FrameProps {\n    name?: string\n    src: string\n    fallback?: Renderable\n    on?: EventDescriptor[]\n  }\n\n  export type ComponentProps<T> = T extends {\n    (props: infer Setup): infer R\n  }\n    ? R extends (props: infer Render) => any\n      ? Setup & Render\n      : Setup\n    : never\n\n  export interface CatchProps {\n    children?: RemixNode\n    fallback?: RemixNode | ((error: Error) => RemixNode)\n  }\n\n  export interface FragmentProps {\n    children?: RemixNode\n  }\n\n  export interface BuiltinElements {\n    Catch: CatchProps\n    Fragment: FragmentProps\n    Frame: FrameProps\n  }\n\n  export type Key = string | number | bigint\n}\n\n/**\n * Create a `RemixElement` (JSX runtime helper). Prefer JSX over calling this directly.\n */\nexport function createElement(\n  type: Remix.ElementType,\n  props: Remix.ElementProps,\n  ...children: Remix.RemixNode[]\n): Remix.RemixElement {\n  // move rest children to props.children\n  if (children.length > 0) {\n    props.children = children\n  }\n\n  return { type, props, $rmx: true }\n}\n\ntype ComponentConfig = {\n  id: string\n  type: Function\n  frame: Remix.FrameHandle\n  raise: (error: unknown) => void\n  getContext: (type: Remix.Component) => unknown\n}\n\nexport type ComponentHandle = ReturnType<typeof createComponent>\n\nexport function createComponent<C = Remix.NoContext>(config: ComponentConfig) {\n  let taskQueue: Remix.Task[] = []\n  let renderCtrl = new AbortController()\n  let connectedCtrl = new AbortController()\n  let contextValue: C | undefined = undefined\n\n  let getContent: null | ((props: Remix.ElementProps) => Remix.RemixNode) = null\n  let scheduleUpdate: (task?: Remix.Task) => void = () => {\n    throw new Error('scheduleUpdate not implemented')\n  }\n\n  let context: Remix.Context<C> = {\n    set: (value: C) => {\n      contextValue = value\n    },\n    get: (type: Remix.Component) => {\n      return config.getContext(type)\n    },\n  }\n\n  let handle: Remix.Handle<C> = {\n    id: config.id,\n    render: (task?: Remix.Task) => {\n      if (task) taskQueue.push(task)\n      scheduleUpdate()\n    },\n    queueTask: (task: Remix.Task) => {\n      taskQueue.push(task)\n    },\n    raise: config.raise,\n    frame: config.frame,\n    context: context,\n    disconnectedSignal: connectedCtrl.signal,\n  }\n\n  function dequeueTasks() {\n    return taskQueue.splice(0, taskQueue.length).map((task) => task.bind(handle, renderCtrl.signal))\n  }\n\n  function render(props: Remix.ElementProps): [Remix.RemixNode, Array<() => void>] {\n    if (connectedCtrl.signal.aborted) {\n      console.warn('render called after component was removed, potential application memory leak')\n      return [null, []]\n    }\n\n    renderCtrl.abort()\n    renderCtrl = new AbortController()\n\n    if (!getContent) {\n      let result = config.type.call(handle, props)\n      if (typeof result === 'function') {\n        getContent = (props) => result.call(handle, props, renderCtrl.signal)\n      } else {\n        getContent = (props) => config.type.call(handle, props)\n      }\n    }\n\n    let node = getContent(props)\n    return [node, dequeueTasks()]\n  }\n\n  function remove(): (() => void)[] {\n    connectedCtrl.abort()\n    return dequeueTasks()\n  }\n\n  function setScheduleUpdate(_scheduleUpdate: (task?: Remix.Task) => void) {\n    scheduleUpdate = _scheduleUpdate\n  }\n\n  function getContextValue(): C | undefined {\n    return contextValue\n  }\n\n  return { render, remove, setScheduleUpdate, frame: config.frame, getContextValue }\n}\n\nexport function Frame(this: Remix.Handle<Remix.FrameHandle>, _: Remix.FrameProps) {\n  return null // reconciler renders\n}\n\nexport function Fragment(_: Remix.FragmentProps) {\n  return null // reconciler renders\n}\n\nexport function Catch(_: Remix.CatchProps) {\n  return null // reconciler renders\n}\n\nexport function createFrameHandle(\n  def?: Partial<{\n    src: string\n    replace: Remix.FrameHandle['replace']\n    reload: Remix.FrameHandle['reload']\n  }>,\n): Remix.FrameHandle {\n  return Object.assign(\n    new EventTarget(),\n    {\n      src: '/',\n      replace: notImplemented('replace not implemented'),\n      reload: notImplemented('reload not implemented'),\n    },\n    def,\n  )\n}\n\nfunction notImplemented(msg: string) {\n  return (): never => {\n    throw new Error(msg)\n  }\n}\n", "/**\n * Use this when framework code is incorrect, indicating an internal bug rather\n * than application code error.\n */\nexport function invariant(assertion: any, message?: string): asserts assertion {\n  let prefix = 'Framework invariant'\n  if (assertion) return\n  throw new Error(message ? `${prefix}: ${message}` : prefix)\n}\n\n/**\n * Use this when application logic is incorrect, indicating a developer error.\n *\n * Using ID-based warnings with external documentation links allows us to:\n * - Update warning messages without releasing new versions\n * - Avoid bloating the library with warning messages or complicating builds\n *   with prod/dev build/export shenanigans\n * - Provide detailed troubleshooting guides and examples\n *\n * `id` is first so we can easily grep the codebase for ensure calls\n */\nexport function ensure(id: number, assertion: boolean): asserts assertion {\n  if (assertion) return\n  throw new Error(`REMIX_${id}: https://rmx.as/w/${id}`)\n}\n", "import { invariant } from './invariant.ts'\nimport type { FrameContext, VirtualRootMarker } from './frame.ts'\n\nexport function diffDom(\n  current: NodeListOf<ChildNode> | Node[],\n  next: NodeListOf<ChildNode> | Node[] | string,\n) {\n  if (typeof next === 'string') {\n    let template = document.createElement('template')\n    template.innerHTML = next\n    next = Array.from(template.content.childNodes)\n  }\n\n  diffNodes(Array.from(current), Array.from(next), {} as FrameContext)\n}\n\nexport function diffNodes(curr: Node[], next: Node[], context: FrameContext) {\n  const parent = curr[0]?.parentNode\n  invariant(parent, 'Parent node not found')\n\n  const max = Math.max(curr.length, next.length)\n  for (let i = 0; i < max; i++) {\n    const c = curr[i]\n    const n = next[i]\n    if (!c && n) {\n      parent.appendChild(n)\n    } else if (c && !n) {\n      parent.removeChild(c)\n    } else if (c && n) {\n      let cursor = diffNode(c, n, context)\n      if (cursor) {\n        i = next.indexOf(cursor)\n      }\n    }\n  }\n}\n\nfunction diffNode(current: Node, next: Node, context: FrameContext): ChildNode | undefined {\n  // Text \u2192 Text\n  if (isTextNode(current) && isTextNode(next)) {\n    const newText = next.textContent || ''\n    if (current.textContent !== newText) current.textContent = newText\n    return\n  }\n\n  // VirtualRootStartMarker \u2192 VirtualRootStartMarker\n  if (isVirtualRootStartMarker(current) && isVirtualRootStartMarker(next)) {\n    let info = context.pendingRoots.get(next)\n    context.pendingRoots.delete(next)\n    invariant(info, 'missing pending virtual root info')\n    let [end, vElement] = info\n    current.$rmx.render(vElement)\n    return end // return cursor to fast forward\n  }\n\n  // Comment \u2192 Comment\n  if (isCommentNode(current) && isCommentNode(next)) {\n    const newData = next.data\n    if (current.data !== newData) current.data = newData\n    return\n  }\n\n  // Element \u2192 Element\n  if (isElement(current) && isElement(next)) {\n    // Different tags: replace\n    if (current.tagName !== next.tagName) {\n      const parent = current.parentNode\n      if (parent) parent.replaceChild(next, current)\n      return\n    }\n\n    // Same tag: update attributes then children\n    diffElementAttributes(current, next, context)\n    diffElementChildren(current, next, context)\n    return\n  }\n\n  // Type mismatch: replace\n  const parent = current.parentNode\n  if (parent) parent.replaceChild(next, current)\n}\n\nfunction diffElementAttributes(current: Element, next: Element, context: FrameContext): void {\n  const prevAttrNames = current.getAttributeNames()\n  const nextAttrNames = next.getAttributeNames()\n\n  const nextNameSet = new Set(nextAttrNames)\n\n  // Removals\n  for (const name of prevAttrNames) {\n    if (!nextNameSet.has(name)) current.removeAttribute(name)\n  }\n\n  // Additions/updates\n  for (const name of nextAttrNames) {\n    const prevVal = current.getAttribute(name)\n    const nextVal = next.getAttribute(name)\n    if (prevVal !== nextVal) current.setAttribute(name, nextVal == null ? '' : String(nextVal))\n  }\n}\n\nfunction diffElementChildren(current: Element, next: Element, context: FrameContext): void {\n  const currentChildren = Array.from(current.childNodes)\n  const nextChildren = Array.from(next.childNodes)\n\n  // Keyed map by data-key for current children\n  const keyToIndex = new Map<string, number>()\n  for (let i = 0; i < currentChildren.length; i++) {\n    const node = currentChildren[i]\n    if (isElement(node)) {\n      const key = node.getAttribute('data-key')\n      if (key != null) keyToIndex.set(key, i)\n    }\n  }\n\n  const used = new Array<boolean>(currentChildren.length).fill(false)\n  const matchIndexForNext = new Array<number>(nextChildren.length).fill(-1)\n\n  for (let i = 0; i < nextChildren.length; i++) {\n    const nextChild = nextChildren[i]\n    let matchIndex = -1\n\n    if (isElement(nextChild)) {\n      const key = nextChild.getAttribute('data-key')\n      if (key != null && keyToIndex.has(key)) {\n        const idx = keyToIndex.get(key)!\n        if (!used[idx]) matchIndex = idx\n      }\n    }\n\n    if (matchIndex === -1) {\n      const candidateIndex = i\n      if (\n        candidateIndex < currentChildren.length &&\n        !used[candidateIndex] &&\n        nodeTypesComparable(currentChildren[candidateIndex], nextChild)\n      ) {\n        matchIndex = candidateIndex\n      }\n    }\n\n    if (matchIndex !== -1) used[matchIndex] = true\n    matchIndexForNext[i] = matchIndex\n  }\n\n  // Forward pass: update matched, collect committed\n  const committed: (Node | undefined)[] = new Array(nextChildren.length)\n  for (let i = 0; i < nextChildren.length; i++) {\n    const mi = matchIndexForNext[i]\n    if (mi !== -1) {\n      const curChild = currentChildren[mi]\n      let cursor = diffNode(curChild, nextChildren[i], context)\n      if (cursor) {\n        // Fast-forward across a hydrated virtual root region.\n        const nextEndIdx = nextChildren.indexOf(cursor)\n        const currEndIdx = findHydrationEndIndex(currentChildren, mi)\n\n        // Mark the entire current region as used to avoid removals.\n        for (let k = mi; k <= currEndIdx; k++) used[k] = true\n\n        // Preserve both boundary markers in committed; skip interior in reorder pass.\n        committed[i] = curChild // start marker\n        committed[nextEndIdx] = currentChildren[currEndIdx] // end marker\n        for (let j = i + 1; j < nextEndIdx; j++) committed[j] = undefined\n\n        // Jump to end of region.\n        i = nextEndIdx\n        continue\n      }\n      committed[i] = curChild\n    } else {\n      committed[i] = nextChildren[i]\n    }\n  }\n\n  // Backward pass: reorder via inserts while avoiding redundant moves\n  let anchor: Node | undefined = undefined\n  for (let i = committed.length - 1; i >= 0; i--) {\n    const node = committed[i]\n    if (!node) continue\n    // Do not move virtual-root boundary markers; keep region stable\n    if (isVirtualRootStartMarker(node) || isVirtualRootEndMarker(node)) {\n      anchor = node\n      continue\n    }\n    let shouldInsert = true\n    if (node.parentNode === current) {\n      if (anchor === undefined) {\n        if (node.nextSibling === null) shouldInsert = false\n      } else {\n        if (node.nextSibling === anchor) shouldInsert = false\n      }\n    }\n    if (shouldInsert) current.insertBefore(node, (anchor as Node | null) || null)\n    anchor = node\n  }\n\n  // Removals\n  for (let i = 0; i < currentChildren.length; i++) {\n    if (!used[i]) {\n      const node = currentChildren[i]\n      if (node.parentNode === current) current.removeChild(node)\n    }\n  }\n}\n\nfunction nodeTypesComparable(a: Node, b: Node): boolean {\n  if (isTextNode(a) && isTextNode(b)) return true\n  if (isElement(a) && isElement(b)) return a.tagName === b.tagName\n  if (isVirtualRootStartMarker(a) && isVirtualRootStartMarker(b)) return true\n  if (isVirtualRootEndMarker(a) && isVirtualRootEndMarker(b)) return true\n  if (isCommentNode(a) && isCommentNode(b)) return true\n  return false\n}\n\nfunction isHydrationEndComment(node: Node): node is Comment {\n  return isCommentNode(node) && node.data.trim() === '/rmx:h'\n}\n\nfunction findHydrationEndIndex(nodes: Node[], startIdx: number): number {\n  for (let j = startIdx + 1; j < nodes.length; j++) {\n    if (isHydrationEndComment(nodes[j])) return j\n  }\n  return startIdx\n}\n\nfunction isTextNode(node: Node): node is Text {\n  return node.nodeType === Node.TEXT_NODE\n}\n\nfunction isElement(node: Node): node is Element {\n  return node.nodeType === Node.ELEMENT_NODE\n}\n\nfunction isCommentNode(node: Node): node is Comment {\n  return node.nodeType === Node.COMMENT_NODE\n}\n\nfunction isVirtualRootStartMarker(node: Node): node is VirtualRootMarker {\n  return isCommentNode(node) && node.data.trim() === 'rmx:h'\n}\n\nfunction isVirtualRootEndMarker(node: Node): node is VirtualRootMarker {\n  return isCommentNode(node) && node.data.trim() === '/rmx:h'\n}\n", "// Core event system types\nimport type { InteractionDescriptor } from './interactions.ts'\n\nlet _debug: boolean = false\nexport function debug() {\n  _debug = true\n}\nfunction log(...args: any[]) {\n  if (_debug) {\n    console.log('DEBUG', ...args)\n  }\n}\n\n/**\n * Adds events to a target and returns a function to clean them up.\n *\n * @example\n * ```ts\n * import { events, dom } from \"@remix-run/events\";\n *\n * let cleanup = events(target, [\n *   dom.click(event => {\n *     console.log(event.target);\n *   })\n * ])\n * ```\n */\nexport function events<Target extends EventTarget>(\n  target: Target,\n  descriptors: EventDescriptor<Target>[],\n): Cleanup\n\n/**\n * Creates a new event container for the given target. Events can be changed\n * dynamically and cleaned up later.\n *\n * @example\n * ```ts\n * import { events, dom } from \"@remix-run/events\";\n *\n * let container= events(target)\n *\n * container.on([\n *   dom.click(event => {\n *     console.log(\"first handler\");\n *   })\n * ]);\n *\n * container.cleanup();\n * ```\n */\nexport function events<Target extends EventTarget>(target: Target): EventContainer\n\nexport function events<Target extends EventTarget>(\n  target: Target,\n  initialDescriptors?: EventDescriptor<Target>[],\n): EventContainer | Cleanup {\n  let descriptors: EventDescriptor<Target>[] = []\n  let cleanups: Cleanup[] = []\n\n  let on = (nextDescriptors: EventDescriptor<Target> | EventDescriptor<Target>[] | undefined) => {\n    if (!nextDescriptors) {\n      nextDescriptors = []\n    }\n\n    if (!Array.isArray(nextDescriptors)) {\n      nextDescriptors = [nextDescriptors]\n    }\n    if (descriptorsChanged(descriptors, nextDescriptors)) {\n      cleanupAll(cleanups)\n      cleanups = []\n\n      if (nextDescriptors.length > 0) {\n        attachAllEvents(target, nextDescriptors, cleanups)\n      }\n\n      descriptors = nextDescriptors\n    } else {\n      updateHandlersInPlace(descriptors, nextDescriptors)\n    }\n  }\n\n  let cleanup = () => {\n    cleanupAll(cleanups)\n    descriptors = []\n    cleanups = []\n  }\n\n  if (initialDescriptors) {\n    on(initialDescriptors)\n    return cleanup\n  }\n\n  return { on, cleanup }\n}\n\n/**\n * Attach a raw string event to a target. Particularly useful for custom\n * elements and web components.\n *\n * @example\n * ```ts\n * import { events, bind } from \"@remix-run/events\";\n *\n * events(target, [\n *   bind(\"custom\", event => {\n *     console.log(event.target);\n *   })\n * ])\n * ```\n */\nexport function bind<E extends Event = Event, ECurrentTarget = any, ETarget = any>(\n  type: string,\n  handler: EventHandler<E, ECurrentTarget, ETarget>,\n  options?: AddEventListenerOptions,\n): EventDescriptor<ECurrentTarget> {\n  return { type, handler, options }\n}\n\nexport type EventHandler<E = Event, ECurrentTarget = any, ETarget = any> = (\n  event: EventWithTargets<E, ECurrentTarget, ETarget>,\n  signal: AbortSignal,\n) => any | Promise<any>\n\nexport interface EventDescriptor<ECurrentTarget = any> {\n  type: string\n  handler: EventHandler<any, ECurrentTarget>\n  isCustom?: boolean\n  options?: AddEventListenerOptions\n}\n\nexport type EventWithTargets<E = Event, ECurrentTarget = any, ETarget = any> = Omit<\n  E,\n  'target' | 'currentTarget'\n> & {\n  target: ETarget\n  currentTarget: ECurrentTarget\n}\n\nexport interface EventContainer {\n  on: (events: EventDescriptor | EventDescriptor[] | undefined) => void\n  cleanup: () => void\n}\n\nexport type Cleanup = () => void\n\nfunction shallowEqual(a: any, b: any): boolean {\n  if (a === b) return true\n  if (!a || !b) return false\n\n  if (typeof a !== 'object' || typeof b !== 'object') return false\n\n  let keysA = Object.keys(a)\n  let keysB = Object.keys(b)\n\n  if (keysA.length !== keysB.length) return false\n\n  for (let key of keysA) {\n    if (a[key] !== b[key]) return false\n  }\n\n  return true\n}\n\nfunction createDispatcher<T extends EventTarget>(target: T, type: string) {\n  return (options?: CustomEventInit, originalEvent?: Event) => {\n    let customEvent = new CustomEvent(type, {\n      bubbles: true,\n      cancelable: true,\n      ...options,\n    })\n\n    // Patch stopPropagation to also stop the original event\n    if (originalEvent) {\n      let originalStopPropagation = customEvent.stopPropagation.bind(customEvent)\n      customEvent.stopPropagation = () => {\n        originalStopPropagation()\n        originalEvent.stopPropagation()\n      }\n    }\n\n    target.dispatchEvent(customEvent)\n  }\n}\n\nfunction prepareInteractions<T extends EventTarget>(\n  target: T,\n  descriptors: InteractionDescriptor<T>[],\n  cleanups: Cleanup[],\n) {\n  // Only prepare once per unique event type (which now includes options in the name)\n  let seenEventTypes = new Set<string>()\n\n  for (let descriptor of descriptors) {\n    if (seenEventTypes.has(descriptor.type)) {\n      continue // Skip if we've already prepared this event type\n    }\n    seenEventTypes.add(descriptor.type)\n\n    let dispatch = createDispatcher(target, descriptor.type)\n\n    let factoryResult = descriptor.factory({ dispatch, target }, descriptor.factoryOptions)\n\n    if (factoryResult) {\n      let factoryCleanups = Array.isArray(factoryResult) ? factoryResult : [factoryResult]\n      cleanups.push(...factoryCleanups)\n    }\n  }\n}\n\nfunction attach<Target extends EventTarget>(\n  target: Target,\n  eventType: string,\n  descriptors: EventDescriptor<Target>[],\n  cleanups: Cleanup[],\n) {\n  log('attach', { target, eventType, descriptors })\n\n  let preventedEvents = new Set<Event>()\n\n  for (let descriptor of descriptors) {\n    let controller = new AbortController()\n    let wrappedHandler = (event: Event) => {\n      controller.abort(new DOMException('Handler reentered', 'EventReentry'))\n      controller = new AbortController()\n\n      log('wrappedHandler', { target, eventType, event })\n\n      if (preventedEvents.has(event)) {\n        log('prevented', { target, eventType, event })\n        return\n      }\n\n      let call = descriptor.handler(event as any, controller.signal)\n      if (call instanceof Promise) {\n        call.catch((e) => {\n          if (e instanceof DOMException && e.name === 'EventReentry') {\n            // swallow\n          } else {\n            throw e\n          }\n        })\n      }\n\n      if (event.defaultPrevented) {\n        preventedEvents.add(event)\n        setTimeout(() => preventedEvents.delete(event), 0)\n      }\n    }\n\n    target.addEventListener(eventType, wrappedHandler, descriptor.options)\n    cleanups.push(() => {\n      controller.abort()\n      target.removeEventListener(eventType, wrappedHandler, descriptor.options)\n    })\n  }\n}\n\nfunction attachStandardEvents<Target extends EventTarget>(\n  target: Target,\n  descriptors: EventDescriptor<Target>[],\n  cleanups: Cleanup[],\n) {\n  let eventsByType = new Map<string, EventDescriptor<Target>[]>()\n\n  for (let descriptor of descriptors) {\n    if (!eventsByType.has(descriptor.type)) {\n      eventsByType.set(descriptor.type, [])\n    }\n    eventsByType.get(descriptor.type)!.push(descriptor)\n  }\n\n  for (let [type, descriptors] of eventsByType) {\n    attach(target, type, descriptors, cleanups)\n  }\n}\n\nfunction attachInteractions<Target extends EventTarget>(\n  target: Target,\n  descriptors: InteractionDescriptor<Target>[],\n  cleanups: Cleanup[],\n) {\n  let byType = new Map<string, InteractionDescriptor<Target>[]>()\n\n  for (let descriptor of descriptors) {\n    if (!byType.has(descriptor.type)) {\n      byType.set(descriptor.type, [])\n    }\n    byType.get(descriptor.type)!.push(descriptor)\n  }\n\n  for (let [type, descriptors] of byType) {\n    attach(target, type, descriptors, cleanups)\n  }\n}\n\nfunction attachAllEvents<Target extends EventTarget>(\n  target: Target,\n  descriptors: EventDescriptor<Target>[],\n  cleanups: Cleanup[],\n) {\n  let { custom, standard } = splitDescriptors(descriptors)\n  prepareInteractions(target, custom, cleanups)\n  attachInteractions(target, custom, cleanups)\n  attachStandardEvents(target, standard, cleanups)\n}\n\nfunction splitDescriptors<Target extends EventTarget>(\n  descriptors: EventDescriptor<Target>[],\n): {\n  custom: InteractionDescriptor<Target>[]\n  standard: EventDescriptor<Target>[]\n} {\n  let custom: InteractionDescriptor[] = []\n  let standard: EventDescriptor[] = []\n  for (let descriptor of descriptors) {\n    if (isInteractionDescriptor(descriptor)) {\n      custom.push(descriptor)\n    } else {\n      standard.push(descriptor)\n    }\n  }\n  return { custom, standard }\n}\n\nfunction isInteractionDescriptor(descriptor: EventDescriptor): descriptor is InteractionDescriptor {\n  return descriptor.isCustom === true\n}\n\nfunction descriptorsChanged<Target extends EventTarget>(\n  descriptors: EventDescriptor<Target>[],\n  nextDescriptors: EventDescriptor<Target>[],\n): boolean {\n  if (descriptors.length !== nextDescriptors.length) {\n    return true\n  }\n\n  for (let i = 0; i < descriptors.length; i++) {\n    let current = descriptors[i]\n    let next = nextDescriptors[i]\n\n    if (\n      current.type !== next.type ||\n      current.isCustom !== next.isCustom ||\n      !shallowEqual(current.options, next.options) ||\n      !shallowEqual((current as any).factoryOptions, (next as any).factoryOptions)\n    ) {\n      return true\n    }\n  }\n\n  return false\n}\n\nfunction updateHandlersInPlace<Target extends EventTarget>(\n  descriptors: EventDescriptor<Target>[],\n  nextDescriptors: EventDescriptor<Target>[],\n) {\n  for (let i = 0; i < nextDescriptors.length; i++) {\n    descriptors[i].handler = nextDescriptors[i].handler\n  }\n}\n\nfunction cleanupAll(cleanups: Cleanup[]) {\n  for (let cleanup of cleanups) cleanup()\n}\n", "import { bind } from './events.ts'\nimport type { EventHandler, EventDescriptor } from './events.ts'\n\ntype EventFromMaps<EventName extends string, EventMap> = EventName extends keyof EventMap\n  ? EventMap[EventName]\n  : Event\n\ntype TargetFunction<ECurrentTarget, EventMap, ETarget = EventTarget> = {\n  // String literal overload that infers event type from EventMap\n  <EventName extends keyof EventMap & string, T = ECurrentTarget>(\n    type: EventName,\n    handler: EventHandler<EventFromMaps<EventName, EventMap>, T, ETarget>,\n    options?: AddEventListenerOptions,\n  ): EventDescriptor<T>\n\n  // Generic overload for custom event types (fallback) - infer T from handler\n  <E extends Event, T = ECurrentTarget>(\n    type: string,\n    handler: EventHandler<E, T, ETarget>,\n    options?: AddEventListenerOptions,\n  ): EventDescriptor<T>\n} & {\n  [EventName in keyof EventMap as EventName extends string ? EventName : never]: {\n    <T = ECurrentTarget>(\n      handler: EventHandler<EventFromMaps<EventName & string, EventMap>, T, ETarget>,\n    ): EventDescriptor<T>\n    <T = ECurrentTarget>(\n      handler: EventHandler<EventFromMaps<EventName & string, EventMap>, T, ETarget>,\n      options: AddEventListenerOptions,\n    ): EventDescriptor<T>\n  }\n}\n\nexport function createTargetProxy<ECurrentTarget, ETarget, EventMap>(): TargetFunction<\n  ECurrentTarget,\n  EventMap,\n  ETarget\n> {\n  return new Proxy(\n    function targetFunction<E extends Event, T = ECurrentTarget>(\n      type: string,\n      handler: EventHandler<E, T, ETarget>,\n      options?: AddEventListenerOptions,\n    ): EventDescriptor<T> {\n      return bind(type, handler, options)\n    } as TargetFunction<ECurrentTarget, EventMap, ETarget>,\n    {\n      get(target, prop) {\n        if (typeof prop === 'string') {\n          return function <T = ECurrentTarget>(\n            handler: EventHandler<EventFromMaps<typeof prop, EventMap>, T, ETarget>,\n            options?: AddEventListenerOptions,\n          ): EventDescriptor<T> {\n            return bind(prop, handler as EventHandler<any, T, ETarget>, options)\n          }\n        }\n        return (target as any)[prop]\n      },\n    },\n  )\n}\n\nexport let dom = createTargetProxy<HTMLElement, EventTarget, HTMLElementEventMap>()\n\nexport let xhr = createTargetProxy<XMLHttpRequest, XMLHttpRequest, XMLHttpRequestEventMap>()\n\nexport let win = createTargetProxy<Window, EventTarget, WindowEventMap>()\nexport let doc = createTargetProxy<Document, EventTarget, DocumentEventMap>()\nexport let ws = createTargetProxy<WebSocket, WebSocket, WebSocketEventMap>()\n", "import type { EventHandler, EventDescriptor, Cleanup } from './events.ts'\n\nexport type InteractionFactory<\n  Target extends EventTarget = EventTarget,\n  Detail = any,\n  Options = any,\n> = (\n  context: {\n    dispatch: (options?: CustomEventInit<Detail>, originalEvent?: Event) => void\n    target: Target\n  },\n  options?: Options,\n) => Cleanup | Cleanup[] | void\n\nexport interface InteractionDescriptor<Target extends EventTarget = EventTarget>\n  extends EventDescriptor<Target> {\n  factory: InteractionFactory<Target>\n  factoryOptions?: any\n}\n\nexport type Interaction<Target extends EventTarget = EventTarget, Detail = any> = {\n  <ECurrentTarget extends EventTarget = Target>(\n    handler: EventHandler<CustomEvent<Detail>, ECurrentTarget>,\n    options?: any,\n  ): InteractionDescriptor<ECurrentTarget>\n}\n\nfunction createEventNameWithOptions(baseName: string, options?: any): string {\n  if (!options || Object.keys(options).length === 0) {\n    return baseName\n  }\n\n  let params = new URLSearchParams()\n  // Sort keys for consistent ordering\n  let sortedKeys = Object.keys(options).sort()\n  for (let key of sortedKeys) {\n    params.append(key, String(options[key]))\n  }\n\n  return `${baseName}?${params.toString()}`\n}\n\nexport function createInteraction<Target extends EventTarget, Detail = any, Options = any>(\n  eventName: string,\n  factory: InteractionFactory<Target, Detail, Options>,\n): Interaction<Target, Detail> {\n  return <ECurrentTarget extends EventTarget = Target>(\n    handler: EventHandler<CustomEvent<Detail>, ECurrentTarget>,\n    options?: Options,\n  ) => {\n    let finalEventName = createEventNameWithOptions(eventName, options)\n\n    return {\n      type: finalEventName,\n      handler: handler as EventHandler<any, ECurrentTarget>,\n      isCustom: true,\n      factoryOptions: options,\n      factory: factory as any,\n    }\n  }\n}\n", "import type { EventHandler, EventDescriptor } from './events.ts'\n\nexport function createEventType<Detail = null>(eventName: string) {\n  let binder = <ECurrentTarget extends EventTarget = EventTarget>(\n    handler: EventHandler<CustomEvent<Detail>, ECurrentTarget>,\n    options?: AddEventListenerOptions,\n  ): EventDescriptor<ECurrentTarget> => {\n    return {\n      type: eventName,\n      handler: handler as EventHandler<any, ECurrentTarget>,\n      options,\n    }\n  }\n\n  let createEvent = (\n    ...args: null extends Detail\n      ? [init?: CustomEventInit<Detail>]\n      : [init: CustomEventInit<Detail> & { detail: Detail }]\n  ): CustomEvent<Detail> => {\n    let init = args[0]\n    return new CustomEvent(eventName, {\n      bubbles: true,\n      cancelable: true,\n      ...init,\n    })\n  }\n\n  return [binder, createEvent] as const\n}\n", "// Style processing and CSS-in-JS system\n\n// Base CSS properties from DOM, following Preact's pattern\nexport type StyleProperties = {\n  [key in keyof Omit<\n    CSSStyleDeclaration,\n    'item' | 'setProperty' | 'removeProperty' | 'getPropertyValue' | 'getPropertyPriority'\n  >]?: string | number | null | undefined\n} & {\n  [key in `--${string}`]?: string | number | null | undefined\n}\n\n// Style object that supports nesting for selectors and media queries\nexport interface EnhancedStyleProperties extends StyleProperties {\n  [key: string]: string | number | null | EnhancedStyleProperties | undefined\n}\n\n// Convert camelCase CSS properties to kebab-case\nfunction camelToKebab(str: string): string {\n  return str.replace(/[A-Z]/g, (letter) => `-${letter.toLowerCase()}`)\n}\n\n// Check if a style property is a nested selector or media query\nfunction isComplexSelector(key: string): boolean {\n  return (\n    key.startsWith('&') ||\n    key.startsWith('@') ||\n    key.startsWith(':') ||\n    key.startsWith('[') ||\n    key.startsWith('.')\n  )\n}\n\n// Detect @keyframes (including vendor-prefixed variants)\nfunction isKeyframesAtRule(key: string): boolean {\n  if (!key.startsWith('@')) return false\n  let lower = key.toLowerCase()\n  return (\n    lower.startsWith('@keyframes') ||\n    lower.startsWith('@-webkit-keyframes') ||\n    lower.startsWith('@-moz-keyframes') ||\n    lower.startsWith('@-o-keyframes')\n  )\n}\n\n// Generate a hash for style objects to create unique class names\nfunction hashStyle(obj: any): string {\n  // Sort keys to ensure consistent hashing, but include values in the string\n  let sortedEntries = Object.entries(obj).sort(([a], [b]) => a.localeCompare(b))\n  let str = JSON.stringify(sortedEntries)\n  let hash = 0\n  for (let i = 0; i < str.length; i++) {\n    let char = str.charCodeAt(i)\n    hash = (hash << 5) - hash + char\n    hash = hash & hash // Convert to 32-bit integer\n  }\n  return Math.abs(hash).toString(36)\n}\n\n// Convert style object to CSS text\nfunction styleToCss(styles: EnhancedStyleProperties, selector: string = ''): string {\n  let baseDeclarations: string[] = []\n  let nestedBlocks: string[] = []\n  let atRules: string[] = []\n  let preludeAtRules: string[] = []\n\n  for (let [key, value] of Object.entries(styles)) {\n    if (isComplexSelector(key)) {\n      if (key.startsWith('@')) {\n        // Some at-rules (e.g., @media) scope declarations to the selector.\n        // Others (e.g., @function) must NOT include the selector in their body.\n        if (key.startsWith('@function')) {\n          let body = atRuleBodyToCss(value as EnhancedStyleProperties)\n          if (body.trim().length > 0) {\n            preludeAtRules.push(`${key} {\\n${indent(body, 2)}\\n}`)\n          } else {\n            preludeAtRules.push(`${key} {\\n}`)\n          }\n        } else if (isKeyframesAtRule(key)) {\n          // Keyframes definitions must not be wrapped with the element selector.\n          // Emit them before the class rule so animations can be referenced.\n          let body = keyframesBodyToCss(value)\n          if (body.trim().length > 0) {\n            preludeAtRules.push(`${key} {\\n${indent(body, 2)}\\n}`)\n          } else {\n            preludeAtRules.push(`${key} {\\n}`)\n          }\n        } else {\n          // Default: keep at-rules nested with the element selector\n          let inner = styleToCss(value as EnhancedStyleProperties, selector)\n          if (inner.trim().length > 0) {\n            atRules.push(`${key} {\\n${indent(inner, 2)}\\n}`)\n          } else {\n            // Empty at-rule body with selector block\n            atRules.push(`${key} {\\n  ${selector} {\\n  }\\n}`)\n          }\n        }\n        continue\n      }\n\n      // For nested selectors, keep them wholesale inside the base block\n      let nestedContent = ''\n      for (let [prop, propValue] of Object.entries(value as Record<string, any>)) {\n        if (propValue != null) {\n          nestedContent += `    ${camelToKebab(prop)}: ${propValue};\\n`\n        }\n      }\n      if (nestedContent) {\n        // Preserve key verbatim (e.g., '&[aria-selected], &[rmx-focus]')\n        nestedBlocks.push(`  ${key} {\\n${nestedContent}  }`)\n      }\n    } else {\n      // Base declaration\n      if (value != null) {\n        baseDeclarations.push(`  ${camelToKebab(key)}: ${value};`)\n      }\n    }\n  }\n\n  let css = ''\n  if (preludeAtRules.length > 0) {\n    css += preludeAtRules.join('\\n')\n  }\n  if (selector && (baseDeclarations.length > 0 || nestedBlocks.length > 0)) {\n    css += (css ? '\\n' : '') + `${selector} {\\n`\n    if (baseDeclarations.length > 0) {\n      css += baseDeclarations.join('\\n') + '\\n'\n    }\n    if (nestedBlocks.length > 0) {\n      css += nestedBlocks.join('\\n') + '\\n'\n    }\n    css += '}'\n  }\n\n  if (atRules.length > 0) {\n    css += (css ? '\\n' : '') + atRules.join('\\n')\n  }\n\n  return css\n}\n\nfunction indent(text: string, spaces: number): string {\n  let pad = ' '.repeat(spaces)\n  return text\n    .split('\\n')\n    .map((line) => (line.length ? pad + line : line))\n    .join('\\n')\n}\n\n// Narrow unknown values to plain record objects\nfunction isRecord(value: unknown): value is Record<string, unknown> {\n  return typeof value === 'object' && value !== null\n}\n\n// Build the body of a @keyframes rule (without wrapping selector)\nfunction keyframesBodyToCss(frames: unknown): string {\n  if (!isRecord(frames)) return ''\n\n  let blocks: string[] = []\n\n  for (let [frameSelector, frameValue] of Object.entries(frames)) {\n    if (!isRecord(frameValue)) {\n      // Skip non-object frame definitions\n      continue\n    }\n\n    let declarations: string[] = []\n    for (let [prop, propValue] of Object.entries(frameValue)) {\n      if (propValue == null) continue\n      // Ignore nested selectors/at-rules inside keyframe steps\n      if (isComplexSelector(prop)) continue\n      declarations.push(`  ${camelToKebab(prop)}: ${propValue};`)\n    }\n\n    if (declarations.length > 0) {\n      blocks.push(`${frameSelector} {\\n${declarations.join('\\n')}\\n}`)\n    } else {\n      blocks.push(`${frameSelector} {\\n}`)\n    }\n  }\n\n  return blocks.join('\\n')\n}\n\n// Build the body for at-rules that should not include a selector wrapper (e.g., @function)\nfunction atRuleBodyToCss(styles: EnhancedStyleProperties): string {\n  let declarations: string[] = []\n  let nested: string[] = []\n\n  for (let [key, value] of Object.entries(styles)) {\n    if (isComplexSelector(key)) {\n      if (key.startsWith('@')) {\n        // Nested at-rules inside definition blocks; render their bodies recursively without selectors\n        let inner = atRuleBodyToCss(value as EnhancedStyleProperties)\n        if (inner.trim().length > 0) {\n          nested.push(`${key} {\\n${indent(inner, 2)}\\n}`)\n        } else {\n          nested.push(`${key} {\\n}`)\n        }\n      } else {\n        // Ignore nested selectors (&, :, ., [) inside definition-style at-rules\n        // They are not meaningful within e.g. @function bodies\n        continue\n      }\n    } else {\n      if (value != null) {\n        declarations.push(`  ${camelToKebab(key)}: ${value};`)\n      }\n    }\n  }\n\n  let body = ''\n  if (declarations.length > 0) {\n    body += declarations.join('\\n')\n  }\n  if (nested.length > 0) {\n    body += (body ? '\\n' : '') + nested.join('\\n')\n  }\n  return body\n}\n\n// Process style prop and return class name and CSS\nexport function processStyle(\n  styleObj: EnhancedStyleProperties,\n  styleCache: Map<string, { className: string; css: string }>,\n): {\n  className: string\n  css: string\n} {\n  // Check if the object is empty\n  if (Object.keys(styleObj).length === 0) {\n    return { className: '', css: '' }\n  }\n\n  // Always extract to CSS class, even for simple styles\n  let hash = hashStyle(styleObj)\n  let className = `rmx-${hash}`\n\n  // Check cache first\n  let cached = styleCache.get(hash)\n  if (cached) {\n    return cached\n  }\n\n  // Generate CSS\n  let css = styleToCss(styleObj, `.${className}`)\n  let result = { className, css }\n\n  // Store in cache\n  styleCache.set(hash, result)\n\n  return result\n}\n\n// Clear style cache (useful for testing)\nexport function clearStyleCache(styleCache: Map<string, { className: string; css: string }>): void {\n  styleCache.clear()\n}\n", "export function createStyleManager(layer: string = 'rmx') {\n  let stylesheet = new CSSStyleSheet()\n  document.adoptedStyleSheets.push(stylesheet)\n\n  // Track usage count per className\n  let counts = new Map<string, number>()\n  let inserted = new Set<string>()\n\n  function has(className: string) {\n    return counts.has(className)\n  }\n\n  function insert(className: string, rule: string) {\n    if (inserted.has(className)) return\n    inserted.add(className)\n    // let current = counts.get(className) || 0\n    // if (current > 0) {\n    //   counts.set(className, current + 1)\n    //   return\n    // }\n    stylesheet.insertRule(`@layer ${layer} { ${rule} }`)\n    // counts.set(className, 1)\n  }\n\n  // DEBUGGING - so no removals right now\n  function remove(className: string) {\n    // let current = counts.get(className)\n    // if (!current) return\n    // if (current > 1) {\n    //   counts.set(className, current - 1)\n    //   return\n    // }\n    // // fully remove\n    // counts.delete(className)\n    // // find the rule index containing this class and delete it\n    // for (let i = 0; i < stylesheet.cssRules.length; i++) {\n    //   let text = (stylesheet.cssRules[i] as any).cssText || ''\n    //   if (text.includes(`.${className}`)) {\n    //     stylesheet.deleteRule(i)\n    //     break\n    //   }\n    // }\n  }\n\n  return { insert, remove, has }\n}\n\n/*\nlet manager = createStyleManager()\nmanager.insert(\"rmx-123\", \".rmx-123 { color: red; }\")\nmanager.remove(\"rmx-123\")\n*/\n", "import {\n  createEventType,\n  events,\n  type EventContainer,\n  type EventDescriptor,\n} from '@remix-run/events'\nimport type { ComponentHandle, Remix } from './component.ts'\nimport { createComponent, Catch, Fragment, Frame, createFrameHandle } from './component.ts'\nimport { invariant } from './invariant.ts'\nimport { processStyle, createStyleManager } from '@remix-run/style'\n\nlet fixmeIdCounter = 0\n\ndeclare module './component.ts' {\n  namespace Remix {\n    export type VirtualRoot = {\n      render: (element: Remix.RemixNode) => void\n      remove: () => void\n      flush: () => void\n    }\n\n    export type VirtualRootOptions = {\n      vParent?: VNode\n      frame?: Remix.FrameHandle\n      scheduler?: Scheduler\n    }\n  }\n}\n\nconst TEXT_NODE = Symbol('TEXT_NODE')\nconst SVG_NS = 'http://www.w3.org/2000/svg'\nconst XLINK_NS = 'http://www.w3.org/1999/xlink'\nconst XML_NS = 'http://www.w3.org/XML/1998/namespace'\n\nlet [connect, createConnectEvent] = createEventType('rmx:connect')\nlet [disconnect, createDisconnectEvent] = createEventType('rmx:disconnect')\n\nexport { connect, disconnect }\n\n// global so all roots share it\nlet styleCache = new Map<string, { className: string; css: string }>()\nlet styleManager =\n  typeof window !== 'undefined'\n    ? createStyleManager()\n    : (null as unknown as ReturnType<typeof createStyleManager>)\n\ntype VNodeType =\n  | typeof ROOT_VNODE\n  | string // host element\n  | Function // component\n  | typeof TEXT_NODE\n  | typeof Fragment\n  | typeof Catch\n  | typeof Frame\n\nexport type VNode<T extends VNodeType = VNodeType> = {\n  type: T\n  props?: Remix.ElementProps\n  key?: Remix.Key\n\n  // _prefixes assigned during reconciliation\n  _parent?: VNode\n  _children?: VNode[]\n  _dom?: unknown\n  _events?: EventContainer\n\n  // TEXT_NODE\n  _text?: string\n\n  // Component\n  _handle?: ComponentHandle\n  _id?: string\n  _content?: VNode\n\n  // Catch\n  _fallback?: ((error: unknown) => Remix.RemixNode) | Remix.RemixNode\n  _added?: VNode[]\n  _tripped?: boolean\n}\n\ntype FragmentNode = VNode & {\n  type: typeof Fragment\n  _children: VNode[]\n}\n\ntype CatchNode = VNode & {\n  type: typeof Catch\n  _children: VNode[] // so we can diff normally in happy path\n  _fallback: ((error: unknown) => Remix.RemixNode) | Remix.RemixNode\n}\n\ntype CommittedCatchNode = CatchNode & {\n  _added: VNode[] // so we can remove arbitrarily (outside render)\n  _tripped: boolean // so we knew we should replace it on next render\n}\n\ntype TextNode = VNode & {\n  type: typeof TEXT_NODE\n  _text: string\n}\n\ntype CommittedTextNode = TextNode & {\n  _dom: Text\n}\n\ntype HostNode = VNode & {\n  type: string\n  props: Remix.ElementProps\n  _children: VNode[]\n}\n\ntype CommittedHostNode = HostNode & {\n  _dom: Element\n}\n\ntype ComponentNode = VNode & {\n  type: Function\n  props: Remix.ElementProps\n  _handle: ComponentHandle\n}\n\ntype CommittedComponentNode = VNode & {\n  type: Function\n  props: Remix.ElementProps\n  _content: VNode\n  _handle: ComponentHandle\n}\n\ntype EmptyFn = () => void\n\nexport type Scheduler = ReturnType<typeof createScheduler>\n\nexport function createScheduler() {\n  let scheduled = new Map<CommittedComponentNode, [ParentNode, Node | undefined]>()\n  let tasks: EmptyFn[] = []\n\n  // TODO: optimize. this is O(k*h), should avoid climbing the tree for already\n  // visited intermediate nodes\n  function ancestorIsScheduled(\n    vnode: VNode,\n    batch: Map<CommittedComponentNode, [ParentNode, Node | undefined]>,\n  ): boolean {\n    let current = vnode._parent\n    while (current) {\n      if (isCommittedComponentNode(current) && batch.has(current)) return true\n      current = current._parent\n    }\n    return false\n  }\n\n  return {\n    enqueue(vnode: CommittedComponentNode, domParent: ParentNode, anchor?: Node): void {\n      scheduled.set(vnode, [domParent, anchor])\n      queueMicrotask(() => this.dequeue())\n    },\n\n    enqueueTasks(newTasks: EmptyFn[]): void {\n      tasks.push(...newTasks)\n      queueMicrotask(() => this.dequeue())\n    },\n\n    dequeue() {\n      let batch = new Map(scheduled)\n      scheduled.clear()\n\n      if (batch.size > 0) {\n        let vnodes = Array.from(batch)\n\n        for (let [vnode, [domParent, anchor]] of vnodes) {\n          if (ancestorIsScheduled(vnode, batch)) continue\n          let handle = vnode._handle\n          let curr = vnode._content\n          let vParent = vnode._parent\n          renderComponent(handle, curr, vnode, domParent, handle.frame, this, vParent, anchor)\n        }\n      }\n\n      if (tasks.length > 0) {\n        for (let task of tasks) {\n          task()\n        }\n        tasks = []\n      }\n    },\n  }\n}\n\nconst ROOT_VNODE = Symbol('ROOT_VNODE')\n\nexport function createRangeRoot(\n  [start, end]: [Node, Node],\n  options: Remix.VirtualRootOptions = {},\n): Remix.VirtualRoot {\n  let root: VNode | null = null\n  let frameStub = options.frame ?? createFrameHandle()\n  let scheduler = options.scheduler ?? createScheduler()\n\n  let container = end.parentNode\n  invariant(container, 'Expected parent node')\n  invariant(end.parentNode === container, 'Boundaries must share parent')\n\n  let hydrationCursor = start.nextSibling\n\n  return {\n    render(element: Remix.RemixNode) {\n      let vnode = toVNode(element)\n      let vParent: VNode = { type: ROOT_VNODE }\n      diffVNodes(root, vnode, container, frameStub, scheduler, vParent, end, hydrationCursor)\n      root = vnode\n      hydrationCursor = null\n    },\n\n    remove() {\n      root = null\n    },\n\n    flush() {\n      scheduler.dequeue()\n    },\n  }\n}\n\nexport function createRoot(\n  container: HTMLElement,\n  options: Remix.VirtualRootOptions = {},\n): Remix.VirtualRoot {\n  let root: VNode | null = null\n  let frameStub = options.frame ?? createFrameHandle()\n  let scheduler = options.scheduler ?? createScheduler()\n  let hydrationCursor = container.innerHTML.trim() !== '' ? container.firstChild : undefined\n\n  return {\n    render(element: Remix.RemixNode) {\n      let vnode = toVNode(element)\n      let vParent: VNode = { type: ROOT_VNODE }\n      diffVNodes(root, vnode, container, frameStub, scheduler, vParent, undefined, hydrationCursor)\n      root = vnode\n      hydrationCursor = undefined\n    },\n\n    remove() {\n      root = null\n    },\n\n    flush() {\n      scheduler.dequeue()\n    },\n  }\n}\n\nfunction flatMapChildrenToVNodes(node: Remix.RemixElement): VNode[] {\n  return 'children' in node.props\n    ? Array.isArray(node.props.children)\n      ? node.props.children.flat(Infinity).map(toVNode)\n      : [toVNode(node.props.children)]\n    : []\n}\n\nexport function toVNode(node: Remix.RemixNode): VNode {\n  if (node === null || node === undefined || typeof node === 'boolean') {\n    return { type: TEXT_NODE, _text: '' }\n  }\n\n  if (typeof node === 'string' || typeof node === 'number' || typeof node === 'bigint') {\n    return { type: TEXT_NODE, _text: String(node) }\n  }\n\n  if (Array.isArray(node)) {\n    return { type: Fragment, _children: node.flat(Infinity).map(toVNode) }\n  }\n\n  if (node.type === Fragment) {\n    return { type: Fragment, _children: flatMapChildrenToVNodes(node) }\n  }\n\n  if (node.type === Catch) {\n    return {\n      type: Catch,\n      _fallback: node.props.fallback,\n      _children: flatMapChildrenToVNodes(node),\n    }\n  }\n\n  if (isRemixElement(node)) {\n    let children = flatMapChildrenToVNodes(node)\n    return { type: node.type, props: node.props, _children: children }\n  }\n\n  invariant(false, 'Unexpected RemixNode')\n}\n\nexport function diffVNodes(\n  curr: VNode | null,\n  next: VNode,\n  domParent: ParentNode,\n  frame: Remix.FrameHandle,\n  scheduler: Scheduler,\n  vParent: VNode,\n  anchor?: Node,\n  rootCursor?: Node | null,\n) {\n  next._parent = vParent // set parent for initial render context lookups\n\n  // new\n  if (curr === null) {\n    insert(next, domParent, frame, scheduler, vParent, anchor, rootCursor)\n    return\n  }\n\n  if (curr.type !== next.type) {\n    replace(curr, next, domParent, frame, scheduler, vParent, anchor)\n    return\n  }\n\n  if (isCommittedTextNode(curr) && isTextNode(next)) {\n    diffText(curr, next, scheduler, vParent)\n    return\n  }\n\n  if (isCommittedHostNode(curr) && isHostNode(next)) {\n    diffHost(curr, next, domParent, frame, scheduler, vParent)\n    return\n  }\n\n  if (isCommittedComponentNode(curr) && isComponentNode(next)) {\n    diffComponent(curr, next, frame, scheduler, domParent, vParent)\n    return\n  }\n\n  if (isFragmentNode(curr) && isFragmentNode(next)) {\n    diffChildren(\n      curr._children,\n      next._children,\n      domParent,\n      frame,\n      scheduler,\n      vParent,\n      undefined,\n      anchor,\n    )\n    return\n  }\n\n  if (isCatchNode(curr) && isCatchNode(next)) {\n    diffCatch(curr, next, domParent, frame, scheduler, vParent)\n    return\n  }\n\n  if (curr.type === Frame && next.type === Frame) {\n    throw new Error('TODO: Frame diff not implemented')\n  }\n\n  invariant(false, 'Unexpected diff case')\n}\n\nfunction diffCatch(\n  curr: CatchNode,\n  next: CatchNode,\n  domParent: ParentNode,\n  frame: Remix.FrameHandle,\n  scheduler: Scheduler,\n  vParent: VNode,\n) {\n  if (curr._tripped) {\n    replace(curr, next, domParent, frame, scheduler, vParent)\n    return\n  }\n\n  let added = []\n  try {\n    for (let i = 0; i < curr._children.length; i++) {\n      let child = curr._children[i]\n      diffVNodes(child, next._children[i], domParent, frame, scheduler, vParent)\n      added.unshift(child)\n    }\n    commitCatch(curr, { _parent: vParent, _tripped: false, _added: added })\n  } catch (e: unknown) {\n    for (let child of added) {\n      remove(child, domParent, scheduler)\n    }\n    let fallbackNode = getCatchFallback(next, e)\n    let anchor = findFirstDomAnchor(curr) || findNextSiblingDomAnchor(curr, vParent) || undefined\n    insert(fallbackNode, domParent, frame, scheduler, vParent, anchor)\n    commitCatch(curr, { _parent: vParent, _tripped: true, _added: [fallbackNode] })\n    dispatchError(e)\n  }\n}\n\nfunction replace(\n  curr: VNode,\n  next: VNode,\n  domParent: ParentNode,\n  frame: Remix.FrameHandle,\n  scheduler: Scheduler,\n  vParent: VNode,\n  anchor?: Node,\n) {\n  anchor =\n    anchor || findFirstDomAnchor(curr) || findNextSiblingDomAnchor(curr, vParent) || undefined\n  insert(next, domParent, frame, scheduler, vParent, anchor)\n  remove(curr, domParent, scheduler)\n}\n\nfunction diffHost(\n  curr: CommittedHostNode,\n  next: HostNode,\n  domParent: ParentNode,\n  frame: Remix.FrameHandle,\n  scheduler: Scheduler,\n  vParent: VNode,\n) {\n  diffChildren(curr._children, next._children, curr._dom, frame, scheduler, next)\n  diffHostProps(curr.props, next.props, curr._dom)\n  let extras = { _dom: curr._dom, _parent: vParent, _events: curr._events }\n  commitHost(next, extras, scheduler, domParent, frame)\n  return\n}\n\nfunction diffCssProp(curr: Remix.ElementProps, next: Remix.ElementProps, dom: Element) {\n  let prevClassName = curr.css ? processStyle(curr.css, styleCache).className : ''\n  let { className, css } = next.css\n    ? processStyle(next.css, styleCache)\n    : { className: '', css: '' }\n  if (prevClassName === className) return\n  if (prevClassName) {\n    dom.classList.remove(prevClassName)\n    styleManager.remove(prevClassName)\n  }\n  if (css && className) {\n    dom.classList.add(className)\n    styleManager.insert(className, css)\n  }\n}\n\nfunction diffHostProps(curr: Remix.ElementProps, next: Remix.ElementProps, dom: Element) {\n  let isSvg = dom.namespaceURI === SVG_NS\n\n  if (next.css || curr.css) {\n    diffCssProp(curr, next, dom)\n  }\n\n  // Removals\n  for (let name in curr) {\n    if (isFrameworkProp(name)) continue\n    if (!(name in next) || next[name] == null) {\n      let { ns, attr } = normalizePropName(name, isSvg)\n      if (ns) dom.removeAttributeNS(ns, attr)\n      else dom.removeAttribute(attr)\n    }\n  }\n\n  // Additions/updates\n  for (let name in next) {\n    if (isFrameworkProp(name)) continue\n    let nextValue = next[name]\n    if (nextValue == null) continue\n    let prevValue = curr[name]\n    if (prevValue !== nextValue) {\n      let { ns, attr } = normalizePropName(name, isSvg)\n      if (\n        attr === 'style' &&\n        typeof nextValue === 'object' &&\n        nextValue &&\n        !Array.isArray(nextValue)\n      ) {\n        dom.setAttribute('style', serializeStyleObject(nextValue))\n      } else {\n        let value = String(nextValue)\n        if (ns) dom.setAttributeNS(ns, attr, nextValue)\n        else dom.setAttribute(attr, value)\n      }\n    }\n  }\n}\n\nfunction isCommittedCatchNode(node: VNode): node is CommittedCatchNode {\n  return isCatchNode(node) && node._added != undefined && node._tripped != null\n}\n\nfunction isComponentNode(node: VNode): node is ComponentNode {\n  return typeof node.type === 'function' && node.type !== Frame\n}\n\nfunction isCommittedComponentNode(node: VNode): node is CommittedComponentNode {\n  return isComponentNode(node) && node._content !== undefined\n}\n\nfunction isFrameworkProp(name: string): boolean {\n  return name === 'children' || name === 'key' || name === 'on' || name === 'css'\n}\n\nconst NUMERIC_CSS_PROPS = new Set([\n  'z-index',\n  'opacity',\n  'flex-grow',\n  'flex-shrink',\n  'flex-order',\n  'grid-area',\n  'grid-row',\n  'grid-column',\n  'font-weight',\n  'line-height',\n  'order',\n  'orphans',\n  'widows',\n  'zoom',\n  'columns',\n  'column-count',\n])\n\n// TODO: would rather actually diff el.style object directly instead of writing\n// to the style attribute\nfunction serializeStyleObject(style: Record<string, unknown>): string {\n  let parts: string[] = []\n  for (let [key, value] of Object.entries(style)) {\n    if (value == null) continue\n    if (typeof value === 'boolean') continue\n    if (typeof value === 'number' && !Number.isFinite(value)) continue\n\n    let cssKey = key.replace(/[A-Z]/g, (m) => `-${m.toLowerCase()}`)\n\n    let shouldAppendPx =\n      typeof value === 'number' &&\n      value !== 0 &&\n      !NUMERIC_CSS_PROPS.has(cssKey) &&\n      !cssKey.startsWith('--')\n\n    let cssValue = shouldAppendPx\n      ? `${value}px`\n      : Array.isArray(value)\n        ? (value as unknown[]).join(', ')\n        : String(value)\n\n    parts.push(`${cssKey}: ${cssValue};`)\n  }\n  return parts.join(' ')\n}\n\nfunction isSvgContext(vParent: VNode): boolean {\n  // Walk up the vnode tree to determine if we're within an SVG subtree.\n  // The nearest 'foreignObject' switches back to HTML context.\n  let current: VNode | undefined = vParent\n  while (current) {\n    if (typeof current.type === 'string') {\n      if (current.type === 'foreignObject') return false\n      if (current.type === 'svg') return true\n    }\n    current = current._parent\n  }\n  return false\n}\n\nfunction normalizePropName(name: string, isSvg: boolean): { ns?: string; attr: string } {\n  // aria-/data- pass through\n  if (name.startsWith('aria-') || name.startsWith('data-')) return { attr: name }\n\n  // DOM property -> HTML mappings\n  if (!isSvg) {\n    if (name === 'className') return { attr: 'class' }\n    if (name === 'htmlFor') return { attr: 'for' }\n    if (name === 'tabIndex') return { attr: 'tabindex' }\n    if (name === 'acceptCharset') return { attr: 'accept-charset' }\n    if (name === 'httpEquiv') return { attr: 'http-equiv' }\n    return { attr: name.toLowerCase() }\n  }\n\n  // SVG namespaced specials\n  if (name === 'xlinkHref') return { ns: XLINK_NS, attr: 'xlink:href' }\n  if (name === 'xmlLang') return { ns: XML_NS, attr: 'xml:lang' }\n  if (name === 'xmlSpace') return { ns: XML_NS, attr: 'xml:space' }\n\n  // SVG preserved-case exceptions\n  if (\n    name === 'viewBox' ||\n    name === 'preserveAspectRatio' ||\n    name === 'gradientUnits' ||\n    name === 'gradientTransform' ||\n    name === 'patternUnits' ||\n    name === 'patternTransform' ||\n    name === 'clipPathUnits' ||\n    name === 'maskUnits' ||\n    name === 'maskContentUnits'\n  ) {\n    return { attr: name }\n  }\n\n  // General SVG: kebab-case\n  return { attr: camelToKebab(name) }\n}\n\nfunction camelToKebab(input: string): string {\n  return input\n    .replace(/([a-z0-9])([A-Z])/g, '$1-$2')\n    .replace(/_/g, '-')\n    .toLowerCase()\n}\n\nfunction diffText(curr: CommittedTextNode, next: TextNode, scheduler: Scheduler, vParent: VNode) {\n  if (curr._text !== next._text) {\n    curr._dom.textContent = next._text\n  }\n  commitText(next, { _dom: curr._dom, _parent: vParent })\n}\n\nfunction logHydrationMismatch(...msg: any[]) {\n  console.error('Hydration mismatch:', ...msg)\n}\n\nfunction insert(\n  node: VNode,\n  domParent: ParentNode,\n  frame: Remix.FrameHandle,\n  scheduler: Scheduler,\n  vParent: VNode,\n  anchor?: Node,\n  cursor?: Node | null,\n): Node | null | undefined {\n  node._parent = vParent // set parent for initial render context lookups\n  cursor = skipComments(cursor ?? null)\n\n  let doInsert = anchor\n    ? (dom: Node) => domParent.insertBefore(dom, anchor)\n    : (dom: Node) => domParent.appendChild(dom)\n\n  if (isTextNode(node)) {\n    if (cursor instanceof Text) {\n      commitText(node, { _dom: cursor, _parent: vParent })\n      // correct hydration mismatch\n      if (cursor.data !== node._text) {\n        logHydrationMismatch('text mismatch', cursor.data, node._text)\n        cursor.data = node._text\n      }\n      return cursor.nextSibling\n    }\n    let dom = document.createTextNode(node._text)\n    commitText(node, { _dom: dom, _parent: vParent })\n    doInsert(dom)\n    return cursor\n  }\n\n  if (isHostNode(node)) {\n    if (cursor instanceof Element) {\n      if (cursor.tagName.toLowerCase() === node.type) {\n        // FIXME: hydrate css prop\n        // correct hydration mismatches\n        diffHostProps({}, node.props, cursor)\n        commitHost(node, { _dom: cursor, _parent: vParent }, scheduler, domParent, frame)\n        let childCursor = cursor.firstChild\n        // FIXME: this breaks other tests\n        // if (node._children.length > 1 && node._children.every(isTextNode)) {\n        //   // special case <span>Text {text}</span> comes as single node from server\n        //   return cursor.nextSibling\n        // }\n        let excess = diffChildren(null, node._children, cursor, frame, scheduler, node, childCursor)\n        if (excess) {\n          logHydrationMismatch('excess', excess)\n        }\n        return cursor.nextSibling\n      } else {\n        logHydrationMismatch('tag', cursor.tagName.toLowerCase(), node.type)\n        cursor.remove()\n        cursor = undefined // stop hydration for this tree\n      }\n    }\n    let inSvg = isSvgContext(vParent) || node.type === 'svg'\n    let dom = inSvg\n      ? document.createElementNS(SVG_NS, node.type)\n      : document.createElement(node.type)\n    diffHostProps({}, node.props, dom)\n    diffChildren(null, node._children, dom, frame, scheduler, node)\n    commitHost(node, { _dom: dom, _parent: vParent }, scheduler, domParent, frame)\n    doInsert(dom)\n    return cursor\n  }\n\n  if (isFragmentNode(node)) {\n    // Insert fragment children in order before the same anchor\n    for (let child of node._children) {\n      cursor = insert(child, domParent, frame, scheduler, vParent, anchor, cursor)\n    }\n    return cursor\n  }\n\n  if (isCatchNode(node)) {\n    let added = []\n    try {\n      // insert like a fragment\n      for (let child of node._children) {\n        insert(child, domParent, frame, scheduler, node, anchor)\n        added.unshift(child)\n      }\n      commitCatch(node, { _parent: vParent, _tripped: false, _added: added })\n    } catch (e: unknown) {\n      let fallback = getCatchFallback(node, e)\n      for (let child of added) {\n        remove(child, domParent, scheduler)\n      }\n      insert(fallback, domParent, frame, scheduler, node, anchor)\n      commitCatch(node, { _parent: vParent, _tripped: true, _added: [fallback] })\n      dispatchError(e)\n    }\n\n    return\n  }\n\n  if (isComponentNode(node)) {\n    diffComponent(null, node, frame, scheduler, domParent, vParent, anchor, cursor)\n    return cursor\n  }\n\n  if (node.type === Frame) {\n    throw new Error('TODO: Frame insert not implemented')\n  }\n\n  if (node.type === Catch) {\n    throw new Error('TODO: Catch insert not implemented')\n  }\n\n  invariant(false, 'Unexpected node type')\n}\n\nfunction renderComponent(\n  handle: ComponentHandle,\n  currContent: VNode | null,\n  next: ComponentNode,\n  domParent: ParentNode,\n  frame: Remix.FrameHandle,\n  scheduler: Scheduler,\n  vParent?: VNode,\n  anchor?: Node,\n  cursor?: Node | null,\n) {\n  let normalizedOn = next.props.on\n    ? Array.isArray(next.props.on)\n      ? next.props.on\n      : [next.props.on]\n    : undefined\n  let props = normalizedOn ? { ...next.props, on: normalizedOn } : next.props\n  let [element, tasks] = handle.render(props)\n  let content = toVNode(element)\n\n  diffVNodes(currContent, content, domParent, frame, scheduler, next, anchor, cursor)\n  let committed = commitComponent(next, { _content: content, _handle: handle, _parent: vParent })\n\n  handle.setScheduleUpdate(() => {\n    scheduler.enqueue(committed, domParent, anchor)\n  })\n\n  scheduler.enqueueTasks(tasks)\n}\n\nfunction diffComponent(\n  curr: CommittedComponentNode | null,\n  next: ComponentNode,\n  frame: Remix.FrameHandle,\n  scheduler: Scheduler,\n  domParent: ParentNode,\n  vParent: VNode,\n  anchor?: Node,\n  cursor?: Node | null,\n) {\n  if (curr === null) {\n    next._handle = createComponent({\n      id: String(++fixmeIdCounter),\n      frame,\n      type: next.type,\n      raise: (error) => {\n        raise(error, next, domParent, frame, scheduler)\n      },\n      getContext: (type) => {\n        return findContextFromAncestry(vParent, type)\n      },\n    })\n\n    renderComponent(next._handle, null, next, domParent, frame, scheduler, vParent, anchor, cursor)\n    return\n  }\n  next._handle = curr._handle\n  let { _content, _handle } = curr\n  renderComponent(_handle, _content, next, domParent, frame, scheduler, vParent, anchor, cursor)\n}\n\nfunction findContextFromAncestry(node: VNode, type: Remix.Component): unknown {\n  let current: VNode | undefined = node\n  while (current) {\n    if (current.type === type && isComponentNode(current)) {\n      return current._handle.getContextValue()\n    }\n    current = current._parent\n  }\n  return undefined\n}\n\nfunction remove(node: VNode, domParent: ParentNode, scheduler: Scheduler) {\n  if (isCommittedTextNode(node)) {\n    domParent.removeChild(node._dom)\n    return\n  }\n\n  if (isCommittedHostNode(node)) {\n    node._dom.dispatchEvent(createDisconnectEvent({ bubbles: false }))\n    domParent.removeChild(node._dom)\n    let _events = node._events\n    if (_events) {\n      // TODO: use abort controllers in @remix-run/events, won't need to manage cleanup\n      scheduler.enqueueTasks([() => _events.cleanup()])\n    }\n    return\n  }\n\n  if (isFragmentNode(node)) {\n    for (let child of node._children) {\n      remove(child, domParent, scheduler)\n    }\n    return\n  }\n\n  if (isCommittedComponentNode(node)) {\n    remove(node._content, domParent, scheduler)\n    let tasks = node._handle.remove()\n    scheduler.enqueueTasks(tasks)\n    return\n  }\n\n  if (isFragmentNode(node)) {\n    for (let child of node._children) {\n      remove(child, domParent, scheduler)\n    }\n    return\n  }\n\n  if (isCommittedCatchNode(node)) {\n    for (let child of node._added) {\n      remove(child, domParent, scheduler)\n    }\n    return\n  }\n}\n\n// TODO: optimize later\nfunction diffChildren(\n  curr: VNode[] | null,\n  next: VNode[],\n  domParent: ParentNode,\n  frame: Remix.FrameHandle,\n  scheduler: Scheduler,\n  vParent: VNode,\n  cursor?: Node | null,\n  anchor?: Node,\n) {\n  if (curr === null) {\n    for (let node of next) {\n      cursor = insert(node, domParent, frame, scheduler, vParent, anchor, cursor)\n    }\n    return cursor\n  }\n  let currLength = curr.length\n  let nextLength = next.length\n\n  for (let i = 0; i < nextLength; i++) {\n    let currentNode = i < currLength ? curr[i] : null\n    diffVNodes(currentNode, next[i], domParent, frame, scheduler, vParent, anchor, cursor)\n  }\n\n  if (currLength > nextLength) {\n    for (let i = nextLength; i < currLength; i++) {\n      let node = curr[i]\n      if (node) remove(node, domParent, scheduler)\n    }\n  }\n}\n\nfunction commitText(node: TextNode, extras: { _dom: Text; _parent?: VNode }): CommittedTextNode {\n  return Object.assign(node, extras)\n}\n\nfunction commitComponent(\n  node: ComponentNode,\n  extras: { _content: VNode; _handle: ComponentHandle; _parent?: VNode },\n): CommittedComponentNode {\n  return Object.assign(node, extras)\n}\n\nfunction commitCatch(\n  node: CatchNode,\n  extras: { _parent?: VNode; _tripped: boolean; _added?: VNode[] },\n): CatchNode {\n  return Object.assign(node, extras)\n}\n\nfunction commitHost(\n  node: HostNode,\n  extras: { _dom: Element; _parent?: VNode; _events?: EventContainer },\n  scheduler: Scheduler,\n  domParent: ParentNode,\n  frame: Remix.FrameHandle,\n): CommittedHostNode {\n  let _dom = extras._dom\n  let _events = extras._events || events(_dom)\n  let on = node.props.on ? (Array.isArray(node.props.on) ? node.props.on : [node.props.on]) : []\n  let raiseError = (error: unknown) => raise(error, node, domParent, frame, scheduler)\n  let wrapped = wrapEvents(on, raiseError)\n  scheduler.enqueueTasks([() => _events.on(wrapped)])\n  if (!_dom.isConnected) {\n    scheduler.enqueueTasks([() => _dom.dispatchEvent(createConnectEvent({ bubbles: false }))])\n  }\n  extras._events = _events\n  return Object.assign(node, extras)\n}\n\nfunction dispatchError(error: unknown) {\n  // TODO: dispatch on root target\n  // console.error(error)\n}\n\nfunction getCatchFallback(vnode: CatchNode, error: unknown): VNode {\n  let content = typeof vnode._fallback === 'function' ? vnode._fallback(error) : vnode._fallback\n  return toVNode(content)\n}\n\nfunction raise(\n  error: unknown,\n  descendant: VNode,\n  domParent: ParentNode,\n  frame: Remix.FrameHandle,\n  scheduler: Scheduler,\n) {\n  let catchBoundary = findCatchBoundary(descendant)\n  if (catchBoundary) {\n    let content = getCatchFallback(catchBoundary, error)\n    let anchor =\n      findFirstDomAnchor(catchBoundary) ||\n      findNextSiblingDomAnchor(catchBoundary, catchBoundary._parent) ||\n      undefined\n    insert(content, domParent, frame, scheduler, catchBoundary, anchor)\n    for (let child of catchBoundary._added) {\n      remove(child, domParent, scheduler)\n    }\n    commitCatch(catchBoundary, { _tripped: true, _added: [content] })\n  } else {\n    dispatchError(error)\n  }\n}\n\nfunction findCatchBoundary(vnode: VNode): CommittedCatchNode | null {\n  let current: VNode | undefined = vnode\n  while (current) {\n    if (isCommittedCatchNode(current)) return current\n    current = current._parent\n  }\n  return null\n}\n\nfunction wrapEvents(on: EventDescriptor | EventDescriptor[], raise: (error: unknown) => void) {\n  if (!Array.isArray(on)) on = [on]\n  return on.map((descriptor) => {\n    let handler = descriptor.handler\n    Object.assign(descriptor, {\n      handler: (event: Event, signal: AbortSignal) => {\n        try {\n          return handler(event, signal)\n        } catch (error) {\n          raise(error)\n        }\n      },\n    })\n    return descriptor\n  })\n}\n\nfunction isFragmentNode(node: VNode): node is FragmentNode {\n  return node.type === Fragment\n}\n\nfunction isCatchNode(node: VNode): node is CatchNode {\n  return node.type === Catch\n}\n\nfunction isTextNode(node: VNode): node is TextNode {\n  return node.type === TEXT_NODE\n}\n\nfunction isCommittedTextNode(node: VNode): node is CommittedTextNode {\n  return isTextNode(node) && node._dom instanceof Text\n}\n\nfunction isHostNode(node: VNode): node is HostNode {\n  return typeof node.type === 'string'\n}\n\nfunction isCommittedHostNode(node: VNode): node is CommittedHostNode {\n  return isHostNode(node) && node._dom instanceof Element\n}\n\nfunction isRemixElement(node: Remix.RemixNode): node is Remix.RemixElement {\n  return typeof node === 'object' && node !== null && '$rmx' in node\n}\n\nfunction findFirstDomAnchor(node: VNode | null | undefined): Node | null {\n  if (!node) return null\n  if (isCommittedTextNode(node)) return node._dom\n  if (isCommittedHostNode(node)) return node._dom\n  if (isCommittedComponentNode(node)) return findFirstDomAnchor(node._content)\n  if (isFragmentNode(node)) {\n    for (let child of node._children) {\n      let dom = findFirstDomAnchor(child)\n      if (dom) return dom\n    }\n  }\n  if (isCommittedCatchNode(node)) {\n    for (let child of node._added) {\n      let dom = findFirstDomAnchor(child)\n      if (dom) return dom\n    }\n  }\n  return null\n}\n\nfunction findNextSiblingDomAnchor(curr: VNode, vParent?: VNode): Node | null {\n  if (!vParent || !Array.isArray(vParent._children)) return null\n  let children = vParent._children\n  let idx = children.indexOf(curr)\n  if (idx === -1) return null\n  for (let i = idx + 1; i < children.length; i++) {\n    let dom = findFirstDomAnchor(children[i])\n    if (dom) return dom\n  }\n  return null\n}\n\nfunction skipComments(cursor: Node | null): Node | null {\n  while (cursor && cursor.nodeType === Node.COMMENT_NODE) {\n    cursor = cursor.nextSibling\n  }\n  return cursor\n}\n", "import { createElement, createFrameHandle, type Remix } from './component.ts'\nimport { invariant } from './invariant.ts'\nimport { diffNodes } from './diff-dom.ts'\nimport type { Scheduler } from './vdom.ts'\nimport { createRangeRoot, createScheduler } from './vdom.ts'\n\ndeclare module './component.ts' {\n  namespace Remix {\n    export interface Frame {\n      render: (content: Remix.FrameContent) => Promise<void>\n      ready: () => Promise<void>\n      flush: () => void\n    }\n  }\n}\n\ninterface FrameContainer {\n  appendChild: (node: Node) => void\n  childNodes: Node[]\n  querySelectorAll: (selector: string) => Element[]\n  querySelector: (selector: string) => Element | null\n  insertBefore: (node: Node, before: Node) => void\n  root: ParentNode\n}\n\ntype FrameRoot = [Comment, Comment] | Element | Document | DocumentFragment\n\ntype FrameMarkerData = {\n  src: string\n  status: 'pending' | 'resolved'\n  name?: string\n  id: string\n}\n\ntype HydrationMarkerData = {\n  moduleUrl: string\n  exportName: string\n  props: Record<string, any>\n}\n\nexport type VirtualRootMarker = Comment & {\n  $rmx: Remix.VirtualRoot\n}\n\ntype PendingHydrationRoots = Map<Comment, [Comment, Remix.RemixElement]>\n\ntype LoadModule = (src: string, name: string) => Promise<Function> | Function\n\ntype ResolveFrame = (src: string) => Promise<Remix.FrameContent> | Remix.FrameContent\n\nexport type FrameContext = {\n  loadModule: LoadModule\n  pendingRoots: PendingHydrationRoots\n  addFrame: (node: Comment) => HTMLScriptElement\n  frame: Remix.FrameHandle\n  scheduler: Scheduler\n}\n\ntype FrameInit = {\n  src: string\n  loadModule: LoadModule\n  pendingHydrationRoots: PendingHydrationRoots\n  marker?: FrameMarkerData\n  scheduler: Scheduler\n  resolveFrame: ResolveFrame\n}\n\nconst TOP_FRAME = Symbol('TOP_FRAME')\n\nconst defaultInit: FrameInit = {\n  loadModule: async () => {\n    throw new Error('loadModule not implemented')\n  },\n  pendingHydrationRoots: new Map(),\n  src: '/',\n  scheduler: createScheduler(),\n  resolveFrame: async () => {\n    throw new Error('resolveFrame not implemented')\n  },\n}\n\nexport function createFrame(root: FrameRoot, init?: Partial<FrameInit>): Remix.Frame {\n  let config = { ...defaultInit, ...init }\n  let container = createContainer(root)\n  let scheduler = config.scheduler\n\n  let frame = createFrameHandle({\n    src: config.src,\n    reload: async () => {\n      let content = await config.resolveFrame(config.src)\n      await render(content)\n    },\n    replace: async (content: Remix.FrameContent) => {\n      await render(content)\n    },\n  })\n\n  let context: FrameContext = {\n    frame,\n    loadModule: config.loadModule,\n    pendingRoots: config.pendingHydrationRoots,\n    scheduler: config.scheduler,\n    addFrame(start) {\n      let end = findEndComment(start)\n      let script = end.nextElementSibling\n      invariant(script instanceof HTMLScriptElement, 'Invalid frame script')\n      let marker = parseFrameScript(script)\n      createFrame([start, end], { ...config, src: marker.src, marker })\n      return script\n    },\n  }\n\n  async function render(content: Remix.FrameContent) {\n    let fragment = typeof content === 'string' ? createFragmentFromString(content) : content\n    let nextContainer = createContainer(fragment)\n    let next = Array.from(nextContainer.childNodes)\n    await populatePendingRoots(nextContainer, context)\n    diffNodes(container.childNodes, next, context)\n    hydratedAndCreateSubFrames(container.childNodes, context)\n  }\n\n  async function hydrate() {\n    await populatePendingRoots(container, context)\n    hydratedAndCreateSubFrames(Array.from(container.childNodes), context)\n    if (config.marker?.status === 'pending') {\n      let earlyContent = getEarlyFrameContent(config.marker.id)\n      if (earlyContent) {\n        await render(earlyContent)\n      } else {\n        setupTemplateObserver(config.marker.id, render)\n      }\n    }\n  }\n\n  let hydratePromise = hydrate()\n\n  return {\n    render,\n    ready: () => hydratePromise,\n    flush: () => scheduler.dequeue(),\n  }\n}\n\nfunction getEarlyFrameContent(id: string) {\n  let template = document.querySelector(`template#${id}`)\n  if (template instanceof HTMLTemplateElement) {\n    let fragment = template.content\n    template.remove()\n    return fragment\n  }\n  return null\n}\n\nfunction setupTemplateObserver(id: string, cb: (fragment: DocumentFragment) => void) {\n  let observer = new MutationObserver(async (mutations) => {\n    for (let mutation of mutations) {\n      for (let node of mutation.addedNodes) {\n        if (node instanceof HTMLTemplateElement && node.id === id) {\n          observer.disconnect()\n          node.remove()\n          cb(node.content)\n        }\n      }\n    }\n  })\n\n  observer.observe(document.body, { childList: true })\n}\n\nfunction parseFrameScript(script: HTMLScriptElement) {\n  let data = JSON.parse(script.textContent || '{}')\n  invariant(isFrameMarker(data))\n  return data\n}\n\nfunction isFrameMarker(object: unknown): object is FrameMarkerData {\n  return (\n    typeof object === 'object' &&\n    object !== null &&\n    'src' in object &&\n    'id' in object &&\n    'status' in object\n  )\n}\n\nfunction findEndComment(comment: Comment) {\n  let node = comment.nextSibling\n  while (node && node.nodeType !== 8) {\n    node = node.nextSibling\n    if (node instanceof Comment && node.data.trim().startsWith('frame:end')) {\n      return node\n    }\n  }\n  throw new Error('End comment not found')\n}\n\nfunction findCommentAbove(anchor: Node, data: string) {\n  let node = anchor.previousSibling\n  while (node && node.nodeType !== 8) {\n    node = node.previousSibling\n    if (node instanceof Comment && node.data.trim() === data) {\n      return node\n    }\n  }\n  invariant(false, 'Start comment not found')\n}\n\nfunction hydrate(\n  vElement: Remix.RemixElement,\n  start: Comment,\n  end: Comment,\n  context: FrameContext,\n) {\n  context.pendingRoots.delete(start)\n\n  let root = createRangeRoot([start, end], {\n    scheduler: context.scheduler,\n    frame: context.frame,\n    // TODO: vParent: context.vParent,\n  })\n\n  Object.defineProperty(start, '$rmx', { value: root, enumerable: false })\n  root.render(vElement)\n}\n\nexport function isVirtualStartMarker(node: Node): node is VirtualRootMarker {\n  return '$rmx' in node\n}\n\nfunction hydratedAndCreateSubFrames(nodes: Node[], context: FrameContext) {\n  for (let i = 0; i < nodes.length; i++) {\n    let node = nodes[i]\n\n    if (node instanceof Comment && context.pendingRoots.has(node)) {\n      let info = context.pendingRoots.get(node)\n      invariant(info, 'Expected hydration element')\n      let [end, element] = info\n      hydrate(element, node, end, context)\n      return // stop scanning, VDOM takes over\n    }\n\n    if (isFrameStart(node)) {\n      let frameScript = context.addFrame(node)\n      // skip frame region, sub frame will manage itself\n      let endIndex = nodes.indexOf(frameScript)\n      if (endIndex !== -1) {\n        i = endIndex\n      }\n      frameScript.remove() // remove frame script\n    } else if (node.childNodes.length > 0) {\n      hydratedAndCreateSubFrames(Array.from(node.childNodes), context)\n    }\n  }\n}\n\nfunction createFragmentFromString(content: string) {\n  let template = document.createElement('template')\n  template.innerHTML = content.trim()\n  return template.content\n}\n\nfunction isFrameStart(node: Node): node is Comment {\n  return node instanceof Comment && node.data.trim().startsWith('frame:start:')\n}\n\nconst hydrationScriptSelector = 'script[type=\"application/json\"][rmx-hydrated]'\n\n// pending roots map is shared by child frames so we can populate from the\n// parent and load all found modules in parallel and keep diffing synchronous\nasync function populatePendingRoots(container: FrameContainer, context: FrameContext) {\n  let scripts = queryHydrationScripts(container)\n  await Promise.all(\n    scripts.map(async (script) => {\n      let data = JSON.parse(script.textContent || '{}')\n      invariant(isHydrationScript(data), 'Invalid hydration script')\n      let mod = await context.loadModule(data.moduleUrl, data.exportName)\n      let vElement = createElement(mod, data.props)\n      let [start, end] = getVirtualRootMarkersFromScript(script)\n      context.pendingRoots.set(start, [end, vElement])\n      script.remove() // remove before diffing\n    }),\n  )\n}\n\nfunction getVirtualRootMarkersFromScript(script: HTMLScriptElement): [Comment, Comment] {\n  let end = script.previousSibling\n  invariant(end instanceof Comment, 'Expected comment')\n  let start = findCommentAbove(end, 'rmx:h')\n  return [start, end]\n}\n\nfunction queryHydrationScripts(container: FrameContainer): HTMLScriptElement[] {\n  return Array.from(container.root.querySelectorAll(hydrationScriptSelector))\n}\n\nfunction isHydrationScript(object: unknown): object is HydrationMarkerData {\n  return (\n    typeof object === 'object' &&\n    object !== null &&\n    'moduleUrl' in object &&\n    'exportName' in object &&\n    'props' in object\n  )\n}\n\nfunction createContainer(container: FrameRoot): FrameContainer {\n  return Array.isArray(container)\n    ? createCommentContainer(container)\n    : createElementContainer(container)\n}\n\nfunction createElementContainer(container: Document | Element | DocumentFragment): FrameContainer {\n  return {\n    root: container,\n    appendChild: (node: Node) => container.appendChild(node),\n    get childNodes() {\n      return Array.from(container.childNodes)\n    },\n    querySelectorAll: (selector: string) => Array.from(container.querySelectorAll(selector)),\n    querySelector: (selector: string) => container.querySelector(selector),\n    insertBefore: (node: Node, before: Node) => container.insertBefore(node, before),\n  }\n}\n\nfunction createCommentContainer(container: [Comment, Comment]): FrameContainer {\n  let root = container[1].parentNode\n  invariant(root, 'Invalid comment container')\n\n  let appendChild = (node: Node) => {\n    root.insertBefore(node, container[1])\n  }\n\n  let getChildNodesBetween = (): Node[] => {\n    let nodes: Node[] = []\n    let node = container[0].nextSibling\n    while (node && node !== container[1]) {\n      nodes.push(node)\n      node = node.nextSibling\n    }\n    return nodes\n  }\n\n  let querySelectorAll = (selector: string) => {\n    let range = document.createRange()\n    range.setStartAfter(container[0])\n    range.setEndBefore(container[1])\n\n    let all = root.querySelectorAll(selector)\n    let results: Element[] = []\n    for (let i = 0; i < all.length; i++) {\n      let el = all[i]\n      if (range.intersectsNode(el)) results.push(el)\n    }\n    return results\n  }\n\n  let querySelector = (selector: string) => {\n    let range = document.createRange()\n    range.setStartAfter(container[0])\n    range.setEndBefore(container[1])\n\n    let all = root.querySelectorAll(selector)\n    for (let i = 0; i < all.length; i++) {\n      let el = all[i]\n      if (range.intersectsNode(el)) return el\n    }\n    return null\n  }\n\n  let insertBefore = (node: Node, before: Node) => {\n    root.insertBefore(node, before)\n  }\n\n  return {\n    get childNodes() {\n      return getChildNodesBetween()\n    },\n    appendChild,\n    querySelectorAll,\n    querySelector,\n    insertBefore,\n    root,\n  }\n}\n"],
  "mappings": "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",
  "names": ["hydrated", "href", "component", "moduleUrl", "exportName", "finalExportName", "createElement", "type", "props", "children", "createComponent", "config", "taskQueue", "renderCtrl", "connectedCtrl", "contextValue", "getContent", "scheduleUpdate", "context", "value", "handle", "task", "dequeueTasks", "render", "result", "remove", "setScheduleUpdate", "_scheduleUpdate", "getContextValue", "Frame", "_", "Fragment", "Catch", "createFrameHandle", "def", "notImplemented", "msg", "invariant", "assertion", "message", "prefix", "diffNodes", "curr", "next", "context", "parent", "invariant", "max", "i", "c", "n", "cursor", "diffNode", "current", "isTextNode", "newText", "isVirtualRootStartMarker", "info", "end", "vElement", "isCommentNode", "newData", "isElement", "diffElementAttributes", "diffElementChildren", "prevAttrNames", "nextAttrNames", "nextNameSet", "name", "prevVal", "nextVal", "currentChildren", "nextChildren", "keyToIndex", "node", "key", "used", "matchIndexForNext", "nextChild", "matchIndex", "idx", "candidateIndex", "nodeTypesComparable", "committed", "mi", "curChild", "nextEndIdx", "currEndIdx", "findHydrationEndIndex", "k", "j", "anchor", "isVirtualRootEndMarker", "shouldInsert", "a", "b", "isHydrationEndComment", "nodes", "startIdx", "_debug", "log", "args", "_debug", "events", "target", "initialDescriptors", "descriptors", "cleanups", "on", "nextDescriptors", "descriptorsChanged", "cleanupAll", "attachAllEvents", "updateHandlersInPlace", "cleanup", "bind", "type", "handler", "options", "shallowEqual", "a", "b", "keysA", "keysB", "key", "createDispatcher", "originalEvent", "customEvent", "originalStopPropagation", "prepareInteractions", "seenEventTypes", "descriptor", "dispatch", "factoryResult", "factoryCleanups", "attach", "eventType", "preventedEvents", "controller", "wrappedHandler", "event", "call", "e", "attachStandardEvents", "eventsByType", "attachInteractions", "byType", "custom", "standard", "splitDescriptors", "isInteractionDescriptor", "i", "current", "next", "createTargetProxy", "type", "handler", "options", "bind", "target", "prop", "dom", "xhr", "win", "doc", "ws", "createEventNameWithOptions", "baseName", "options", "params", "sortedKeys", "key", "createInteraction", "eventName", "factory", "handler", "createEventType", "eventName", "handler", "options", "args", "init", "camelToKebab", "str", "letter", "isComplexSelector", "key", "isKeyframesAtRule", "lower", "hashStyle", "obj", "sortedEntries", "a", "b", "hash", "char", "styleToCss", "styles", "selector", "baseDeclarations", "nestedBlocks", "atRules", "preludeAtRules", "value", "body", "atRuleBodyToCss", "indent", "keyframesBodyToCss", "inner", "nestedContent", "prop", "propValue", "css", "text", "spaces", "pad", "line", "isRecord", "frames", "blocks", "frameSelector", "frameValue", "declarations", "nested", "processStyle", "styleObj", "styleCache", "className", "cached", "result", "createStyleManager", "layer", "stylesheet", "counts", "inserted", "has", "className", "insert", "rule", "remove", "fixmeIdCounter", "TEXT_NODE", "SVG_NS", "XLINK_NS", "XML_NS", "connect", "createConnectEvent", "createEventType", "disconnect", "createDisconnectEvent", "styleCache", "styleManager", "createStyleManager", "createScheduler", "scheduled", "tasks", "ancestorIsScheduled", "vnode", "batch", "current", "isCommittedComponentNode", "domParent", "anchor", "newTasks", "vnodes", "handle", "curr", "vParent", "renderComponent", "task", "ROOT_VNODE", "createRangeRoot", "start", "end", "options", "root", "frameStub", "createFrameHandle", "scheduler", "container", "invariant", "hydrationCursor", "element", "toVNode", "diffVNodes", "flatMapChildrenToVNodes", "node", "toVNode", "TEXT_NODE", "Fragment", "Catch", "isRemixElement", "children", "invariant", "diffVNodes", "curr", "next", "domParent", "frame", "scheduler", "vParent", "anchor", "rootCursor", "insert", "replace", "isCommittedTextNode", "isTextNode", "diffText", "isCommittedHostNode", "isHostNode", "diffHost", "isCommittedComponentNode", "isComponentNode", "diffComponent", "isFragmentNode", "diffChildren", "isCatchNode", "diffCatch", "Frame", "added", "i", "child", "commitCatch", "e", "remove", "fallbackNode", "getCatchFallback", "findFirstDomAnchor", "findNextSiblingDomAnchor", "diffHostProps", "extras", "commitHost", "diffCssProp", "dom", "prevClassName", "processStyle", "styleCache", "className", "css", "styleManager", "isSvg", "SVG_NS", "name", "isFrameworkProp", "ns", "attr", "normalizePropName", "nextValue", "serializeStyleObject", "value", "isCommittedCatchNode", "NUMERIC_CSS_PROPS", "style", "parts", "key", "cssKey", "m", "cssValue", "isSvgContext", "current", "XLINK_NS", "XML_NS", "camelToKebab", "input", "commitText", "logHydrationMismatch", "msg", "cursor", "skipComments", "doInsert", "childCursor", "excess", "fallback", "renderComponent", "handle", "currContent", "normalizedOn", "props", "element", "tasks", "content", "committed", "commitComponent", "createComponent", "fixmeIdCounter", "error", "raise", "type", "findContextFromAncestry", "_content", "_handle", "createDisconnectEvent", "_events", "currLength", "nextLength", "currentNode", "_dom", "events", "on", "wrapped", "wrapEvents", "createConnectEvent", "getCatchFallback", "vnode", "error", "content", "toVNode", "raise", "descendant", "domParent", "frame", "scheduler", "catchBoundary", "findCatchBoundary", "anchor", "findFirstDomAnchor", "findNextSiblingDomAnchor", "insert", "child", "remove", "commitCatch", "current", "isCommittedCatchNode", "wrapEvents", "on", "descriptor", "handler", "event", "signal", "isFragmentNode", "node", "Fragment", "isCatchNode", "Catch", "isTextNode", "TEXT_NODE", "isCommittedTextNode", "isHostNode", "isCommittedHostNode", "isRemixElement", "isCommittedComponentNode", "dom", "curr", "vParent", "children", "idx", "skipComments", "cursor", "TOP_FRAME", "defaultInit", "createScheduler", "createFrame", "root", "init", "config", "container", "createContainer", "scheduler", "context", "createFrameHandle", "content", "render", "start", "end", "findEndComment", "script", "invariant", "marker", "parseFrameScript", "fragment", "createFragmentFromString", "nextContainer", "next", "populatePendingRoots", "diffNodes", "hydratedAndCreateSubFrames", "hydrate", "earlyContent", "getEarlyFrameContent", "setupTemplateObserver", "hydratePromise", "id", "template", "cb", "observer", "mutations", "mutation", "node", "data", "isFrameMarker", "object", "comment", "findCommentAbove", "anchor", "vElement", "createRangeRoot", "hydratedAndCreateSubFrames", "nodes", "context", "i", "node", "info", "invariant", "end", "element", "hydrate", "isFrameStart", "frameScript", "endIndex", "createFragmentFromString", "content", "template", "hydrationScriptSelector", "populatePendingRoots", "container", "scripts", "queryHydrationScripts", "script", "data", "isHydrationScript", "mod", "vElement", "createElement", "start", "getVirtualRootMarkersFromScript", "findCommentAbove", "object", "createContainer", "createCommentContainer", "createElementContainer", "selector", "before", "root", "appendChild", "getChildNodesBetween", "range", "all", "results", "el"]
}
